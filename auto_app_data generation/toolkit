#!/bin/bash
set -euo pipefail

# ═══════════════════════════════════════════════════════════════════════════
# PROFESSIONAL DATA TOOLKIT
# ═══════════════════════════════════════════════════════════════════════════
# Master script for data management and GitHub operations
# Supports multiple projects with easy switching
# ═══════════════════════════════════════════════════════════════════════════

TOOLKIT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load core libraries
source "$TOOLKIT_ROOT/core/lib/colors.sh"
source "$TOOLKIT_ROOT/core/lib/logger.sh"
source "$TOOLKIT_ROOT/core/lib/paths.sh"

# ───────────────────────────────────────────────────────────────────────────
# Usage
# ───────────────────────────────────────────────────────────────────────────

show_usage() {
    print_box "Professional Data Toolkit"
    cat << EOF

Usage: $0 --project PROJECT_NAME COMMAND [options]

REQUIRED:
  --project NAME          Project to use (e.g., jlearn)

COMMANDS:

  Configuration:
    config                Show current configuration
    validate              Validate configuration and paths
    
  GitHub Operations:
    setup                 Initial GitHub repository setup (first time)
    upload                Upload data to GitHub
    sync                  Full sync (validate + upload + test)
    
  Testing:
    verify                Verify local data integrity
    test-urls             Test GitHub URLs are accessible
    test-all              Run all tests
    
  Information:
    projects              List available projects
    help                  Show this help message
    version               Show version information

EXAMPLES:

  # Setup new GitHub repository
  $0 --project jlearn setup
  
  # Upload data to GitHub
  $0 --project jlearn upload
  
  # Full workflow
  $0 --project jlearn sync
  
  # Use different project
  $0 --project myapp upload
  
  # List available projects
  $0 projects

ADDING NEW PROJECTS:

  1. Copy project folder:
     cp -r projects/jlearn projects/mynewapp
     
  2. Edit configuration:
     nano projects/mynewapp/config.sh
     
  3. Use it:
     $0 --project mynewapp setup

EOF
}

# ───────────────────────────────────────────────────────────────────────────
# Command handlers
# ───────────────────────────────────────────────────────────────────────────

cmd_config() {
    print_section "Project Configuration"
    echo "Project: $PROJECT_NAME"
    echo "Description: $PROJECT_DESCRIPTION"
    echo ""
    echo "GitHub:"
    echo "  Repository: $GITHUB_USERNAME/$GITHUB_REPO_NAME"
    echo "  Branch: $GITHUB_BRANCH"
    echo "  URL: $GITHUB_REPO_URL"
    echo ""
    echo "Paths:"
    echo "  Project Root: $PROJECT_ROOT"
    echo "  Source Data: $SOURCE_DATA_PATH"
    echo "  App Resources: $APP_RESOURCES_PATH"
    echo ""
    echo "GitHub Structure:"
    echo "  Data Folder: $GITHUB_DATA_DIR"
    echo "  Raw Base URL: $RAW_BASE_URL"
    echo ""
}

cmd_validate() {
    print_section "Validating Configuration"
    
    if validate_paths; then
        log_success "Configuration is valid"
        return 0
    else
        log_error "Configuration validation failed"
        return 1
    fi
}

cmd_setup() {
    bash "$TOOLKIT_ROOT/core/tools/setup.sh"
}

cmd_upload() {
    bash "$TOOLKIT_ROOT/core/tools/upload.sh"
}

cmd_verify() {
    source "$TOOLKIT_ROOT/core/lib/validator.sh"
    validate_all_data
}

cmd_sync() {
    print_box "Full Sync Workflow"
    echo ""
    
    # Step 1: Verify
    log_step 1 3 "Verifying data integrity..."
    if ! cmd_verify; then
        log_error "Data verification failed"
        return 1
    fi
    echo ""
    
    # Step 2: Upload
    log_step 2 3 "Uploading to GitHub..."
    if ! cmd_upload; then
        log_error "Upload failed"
        return 1
    fi
    echo ""
    
    # Step 3: Test
    log_step 3 3 "Testing GitHub URLs..."
    cmd_test_urls || log_warning "URL tests failed - data may not be accessible yet"
    
    echo ""
    log_success "Full sync complete!"
}

cmd_test_urls() {
    print_section "Testing GitHub URLs"
    
    local success=0
    local failed=0
    
    for file in "${TEST_FILES[@]}"; do
        local url="$RAW_BASE_URL/$file"
        log_task "Testing $file"
        
        if curl -s -f -o /dev/null --max-time $URL_TEST_TIMEOUT "$url" 2>/dev/null; then
            log_task_done
            success=$((success + 1))
        else
            log_task_failed
            failed=$((failed + 1))
        fi
    done
    
    echo ""
    log_summary $success $failed
    
    if [ $failed -eq 0 ]; then
        log_success "All URLs accessible"
        return 0
    else
        log_error "Some URLs not accessible"
        return 1
    fi
}

cmd_test_all() {
    print_box "Running All Tests"
    echo ""
    
    local passed=0
    local failed=0
    
    # Test 1: Data integrity
    log_step 1 2 "Data Integrity"
    if cmd_verify; then
        passed=$((passed + 1))
    else
        failed=$((failed + 1))
    fi
    echo ""
    
    # Test 2: GitHub URLs
    log_step 2 2 "GitHub URLs"
    if cmd_test_urls; then
        passed=$((passed + 1))
    else
        failed=$((failed + 1))
    fi
    
    echo ""
    log_summary $passed $failed
    
    [ $failed -eq 0 ]
}

cmd_projects() {
    print_section "Available Projects"
    
    local projects_dir="$TOOLKIT_ROOT/projects"
    
    if [ ! -d "$projects_dir" ]; then
        log_error "Projects directory not found"
        return 1
    fi
    
    for project_dir in "$projects_dir"/*; do
        if [ -d "$project_dir" ] && [ -f "$project_dir/config.sh" ]; then
            local project_name=$(basename "$project_dir")
            
            # Load config to get description
            (
                source "$project_dir/config.sh" 2>/dev/null
                printf "  ${COLOR_CYAN}%-15s${COLOR_NC} %s\n" "$project_name" "$PROJECT_DESCRIPTION"
            )
        fi
    done
    
    echo ""
    log_info "Use: $0 --project PROJECT_NAME COMMAND"
}

cmd_version() {
    echo "Professional Data Toolkit"
    echo "Version: 2.0"
    echo "Last Updated: 2025-11-25"
    echo ""
    echo "Features:"
    echo "  - Multi-project support"
    echo "  - Professional logging"
    echo "  - Comprehensive validation"
    echo "  - GitHub integration"
    echo ""
}

# ───────────────────────────────────────────────────────────────────────────
# Main
# ───────────────────────────────────────────────────────────────────────────

main() {
    # Parse arguments
    local project_name=""
    local command=""
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --project)
                project_name="$2"
                shift 2
                ;;
            --help|-h|help)
                show_usage
                exit 0
                ;;
            projects)
                cmd_projects
                exit 0
                ;;
            version)
                cmd_version
                exit 0
                ;;
            *)
                if [ -z "$command" ]; then
                    command="$1"
                fi
                shift
                ;;
        esac
    done
    
    # Validate project specified (except for special commands)
    if [ -z "$project_name" ] && [ "$command" != "projects" ] && [ "$command" != "version" ]; then
        color_error "Error: --project required"
        echo ""
        echo "Usage: $0 --project PROJECT_NAME COMMAND"
        echo "Run '$0 projects' to see available projects"
        echo "Run '$0 --help' for more information"
        exit 1
    fi
    
    # Load project configuration
    if [ -n "$project_name" ]; then
        if ! load_project_config "$project_name"; then
            exit 1
        fi
    fi
    
    # Execute command
    case "$command" in
        config)
            cmd_config
            ;;
        validate)
            cmd_validate
            ;;
        setup)
            cmd_setup
            ;;
        upload)
            cmd_upload
            ;;
        verify)
            cmd_verify
            ;;
        sync)
            cmd_sync
            ;;
        test-urls)
            cmd_test_urls
            ;;
        test-all)
            cmd_test_all
            ;;
        "")
            show_usage
            exit 1
            ;;
        *)
            color_error "Unknown command: $command"
            echo ""
            echo "Run '$0 --help' for usage information"
            exit 1
            ;;
    esac
}

main "$@"

