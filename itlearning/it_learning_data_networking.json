{
  "category": "Networking",
  "categoryId": "networking",
  "version": "2.0.0",
  "description": "Computer networking fundamentals and protocols",
  "icon": "network",
  "color": "#4ECDC4",
  "topics": [
    {
      "id": "osi_model",
      "title": "OSI Model",
      "symbol": "ðŸ“¶",
      "level": "beginner",
      "definition": {
        "text": "The OSI (Open Systems Interconnection) Model is a conceptual framework that standardizes network communication into 7 layers. Each layer has specific responsibilities and communicates with adjacent layers. Understanding OSI helps troubleshoot network issues systematically.",
        "keyTerms": ["Physical", "Data Link", "Network", "Transport", "Session", "Presentation", "Application"]
      },
      "keyFormulas": [
        {
          "id": "osi_layers",
          "name": "7 Layers",
          "formula": "Application â†’ Presentation â†’ Session â†’ Transport â†’ Network â†’ Data Link â†’ Physical",
          "latex": null,
          "meaning": "Remember: 'All People Seem To Need Data Processing'"
        }
      ],
      "examples": [
        {
          "id": "osi_ex1",
          "question": "Which layer handles IP addressing?",
          "steps": [
            {"step": 1, "action": "IP addresses route packets between networks", "result": "Routing function", "explanation": "Not within a single network"},
            {"step": 2, "action": "Layer 3 handles logical addressing", "result": "Network Layer", "explanation": "IP is a Layer 3 protocol"},
            {"step": 3, "action": "Routers operate at this layer", "result": "Layer 3 devices", "explanation": "Make routing decisions"}
          ],
          "finalAnswer": "Network Layer (Layer 3) handles IP addressing and routing",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Network Troubleshooting", "description": "Diagnose issues layer by layer"},
        {"title": "Protocol Design", "description": "Understand where protocols fit"},
        {"title": "Security", "description": "Apply security at appropriate layers"}
      ],
      "tips": [
        "TCP/IP model (4 layers) is more commonly used in practice",
        "Layers 1-4 are about data transport, 5-7 about data handling",
        "Each layer adds its own header (encapsulation)"
      ]
    },
    {
      "id": "tcp_ip",
      "title": "TCP/IP Protocol Suite",
      "symbol": "ðŸŒ",
      "level": "beginner",
      "definition": {
        "text": "TCP/IP is the foundational protocol suite of the Internet. TCP (Transmission Control Protocol) provides reliable, ordered, error-checked delivery of data. IP (Internet Protocol) handles addressing and routing packets across networks.",
        "keyTerms": ["TCP", "UDP", "IP", "Port", "Socket", "Handshake", "Packet"]
      },
      "keyFormulas": [
        {
          "id": "tcp_vs_udp",
          "name": "TCP vs UDP",
          "formula": "TCP: Reliable, ordered, slow | UDP: Unreliable, fast, no connection",
          "latex": null,
          "meaning": "Choose based on reliability vs speed needs"
        }
      ],
      "examples": [
        {
          "id": "tcp_ex1",
          "question": "Explain the TCP 3-way handshake",
          "steps": [
            {"step": 1, "action": "Client sends SYN", "result": "SYN sent to server", "explanation": "Request to synchronize"},
            {"step": 2, "action": "Server responds SYN-ACK", "result": "Acknowledge + own SYN", "explanation": "Server agrees and requests sync"},
            {"step": 3, "action": "Client sends ACK", "result": "Connection established", "explanation": "Both sides synchronized"}
          ],
          "finalAnswer": "SYN â†’ SYN-ACK â†’ ACK establishes a TCP connection",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Web Browsing", "description": "HTTP over TCP for reliable page loading"},
        {"title": "Video Streaming", "description": "Often UDP for real-time performance"},
        {"title": "Gaming", "description": "UDP for low-latency game updates"},
        {"title": "Email", "description": "SMTP/IMAP use TCP"}
      ],
      "codeExample": {
        "python": "import socket\n\n# TCP client\nclient = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nclient.connect(('localhost', 8080))\nclient.send(b'Hello, server!')\nresponse = client.recv(1024)\nclient.close()\n\n# UDP client\nudp_client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_client.sendto(b'Hello', ('localhost', 8080))\ndata, addr = udp_client.recvfrom(1024)",
        "javascript": "// Node.js TCP client\nconst net = require('net');\nconst client = net.createConnection({ port: 8080 }, () => {\n  client.write('Hello, server!');\n});\nclient.on('data', (data) => {\n  console.log(data.toString());\n  client.end();\n});"
      },
      "tips": [
        "Use TCP when data integrity matters (files, web pages)",
        "Use UDP for real-time applications (video calls, games)",
        "Port numbers identify specific services (80=HTTP, 443=HTTPS)"
      ]
    },
    {
      "id": "http_https",
      "title": "HTTP & HTTPS",
      "symbol": "ðŸ”’",
      "level": "beginner",
      "definition": {
        "text": "HTTP (Hypertext Transfer Protocol) is the foundation of web communication. It's a request-response protocol where clients request resources and servers respond. HTTPS adds TLS/SSL encryption for security, protecting data in transit.",
        "keyTerms": ["Request", "Response", "Status Code", "Header", "Body", "TLS", "SSL", "Certificate"]
      },
      "keyFormulas": [
        {
          "id": "http_methods",
          "name": "HTTP Methods",
          "formula": "GET (read) | POST (create) | PUT (replace) | PATCH (update) | DELETE (remove)",
          "latex": null,
          "meaning": "Standard methods for different operations"
        }
      ],
      "examples": [
        {
          "id": "http_ex1",
          "question": "What do HTTP status codes mean?",
          "steps": [
            {"step": 1, "action": "1xx: Informational", "result": "Request received, continuing", "explanation": "Rare in practice"},
            {"step": 2, "action": "2xx: Success", "result": "200 OK, 201 Created", "explanation": "Request succeeded"},
            {"step": 3, "action": "3xx: Redirection", "result": "301 Moved, 304 Not Modified", "explanation": "Further action needed"},
            {"step": 4, "action": "4xx: Client Error", "result": "400 Bad Request, 404 Not Found", "explanation": "Client made an error"},
            {"step": 5, "action": "5xx: Server Error", "result": "500 Internal Error, 503 Unavailable", "explanation": "Server failed"}
          ],
          "finalAnswer": "First digit indicates category: 2xx success, 4xx client error, 5xx server error",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Web APIs", "description": "RESTful services use HTTP methods"},
        {"title": "Browser Communication", "description": "All web pages use HTTP/HTTPS"},
        {"title": "Webhooks", "description": "Event notifications via HTTP POST"},
        {"title": "CDNs", "description": "Content delivery using HTTP caching"}
      ],
      "codeExample": {
        "python": "import requests\n\n# GET request\nresponse = requests.get('https://api.example.com/users')\nprint(response.status_code)  # 200\nprint(response.json())\n\n# POST request with data\nresponse = requests.post(\n    'https://api.example.com/users',\n    json={'name': 'Alice', 'email': 'alice@example.com'},\n    headers={'Authorization': 'Bearer token'}\n)",
        "javascript": "// Fetch API\nconst response = await fetch('https://api.example.com/users', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json',\n    'Authorization': 'Bearer token'\n  },\n  body: JSON.stringify({ name: 'Alice' })\n});\nconst data = await response.json();"
      },
      "tips": [
        "Always use HTTPS in production for security",
        "Check status codes - don't assume success",
        "Use appropriate HTTP methods for different operations"
      ]
    },
    {
      "id": "dns",
      "title": "DNS (Domain Name System)",
      "symbol": "ðŸ“–",
      "level": "beginner",
      "definition": {
        "text": "DNS is the Internet's phone book - it translates human-readable domain names (like google.com) into IP addresses (like 142.250.80.46). DNS is a distributed, hierarchical system with multiple types of records for different purposes.",
        "keyTerms": ["Domain", "IP Address", "DNS Server", "A Record", "CNAME", "MX Record", "TTL", "Resolver"]
      },
      "keyFormulas": [
        {
          "id": "dns_records",
          "name": "DNS Record Types",
          "formula": "A: IPv4 | AAAA: IPv6 | CNAME: Alias | MX: Mail | TXT: Text | NS: Nameserver",
          "latex": null,
          "meaning": "Different records serve different purposes"
        }
      ],
      "examples": [
        {
          "id": "dns_ex1",
          "question": "How does DNS resolution work?",
          "steps": [
            {"step": 1, "action": "Browser checks local cache", "result": "Cache miss", "explanation": "First lookup"},
            {"step": 2, "action": "Query recursive resolver (ISP)", "result": "Resolver checks its cache", "explanation": "Often cached here"},
            {"step": 3, "action": "Query root server", "result": "Returns TLD server (.com)", "explanation": "Top of hierarchy"},
            {"step": 4, "action": "Query TLD server", "result": "Returns authoritative server", "explanation": "Domain's nameserver"},
            {"step": 5, "action": "Query authoritative server", "result": "Returns IP address", "explanation": "Final answer"}
          ],
          "finalAnswer": "DNS resolution cascades through hierarchy: Local â†’ ISP â†’ Root â†’ TLD â†’ Authoritative",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Website Hosting", "description": "Point domain to server IP"},
        {"title": "Email Delivery", "description": "MX records route emails"},
        {"title": "Load Balancing", "description": "Multiple A records distribute traffic"},
        {"title": "CDN Configuration", "description": "CNAME to CDN endpoints"}
      ],
      "codeExample": {
        "bash": "# DNS lookup commands\nnslookup google.com\ndig google.com A\ndig google.com MX\ndig google.com +trace  # Full resolution path\n\n# Check specific DNS server\ndig @8.8.8.8 google.com\n\n# View all records\ndig google.com ANY"
      },
      "tips": [
        "TTL (Time To Live) controls caching duration",
        "Use low TTL before DNS changes, increase after",
        "CNAME can't be used at zone apex (root domain)"
      ]
    },
    {
      "id": "ip_addressing",
      "title": "IP Addressing & Subnetting",
      "symbol": "ðŸ”¢",
      "level": "intermediate",
      "definition": {
        "text": "IP addresses uniquely identify devices on a network. IPv4 uses 32-bit addresses (e.g., 192.168.1.1), while IPv6 uses 128-bit addresses. Subnetting divides networks into smaller segments for better management and security.",
        "keyTerms": ["IPv4", "IPv6", "Subnet", "CIDR", "Netmask", "Private IP", "Public IP", "NAT"]
      },
      "keyFormulas": [
        {
          "id": "cidr_notation",
          "name": "CIDR Notation",
          "formula": "192.168.1.0/24 = 256 addresses (254 usable) | /16 = 65,536 | /8 = 16.7M",
          "latex": null,
          "meaning": "Number after slash = network bits"
        }
      ],
      "examples": [
        {
          "id": "ip_ex1",
          "question": "How many usable hosts in a /24 network?",
          "steps": [
            {"step": 1, "action": "Calculate host bits: 32 - 24 = 8", "result": "8 host bits", "explanation": "Bits for hosts"},
            {"step": 2, "action": "Calculate total addresses: 2^8 = 256", "result": "256 addresses", "explanation": "All possible combinations"},
            {"step": 3, "action": "Subtract network and broadcast", "result": "256 - 2 = 254", "explanation": "Network (.0) and broadcast (.255) reserved"}
          ],
          "finalAnswer": "A /24 network has 254 usable host addresses",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Network Design", "description": "Plan IP allocation for organizations"},
        {"title": "Cloud Infrastructure", "description": "VPC subnet configuration"},
        {"title": "Security", "description": "Network segmentation for isolation"},
        {"title": "Home Networking", "description": "Router DHCP configuration"}
      ],
      "codeExample": {
        "python": "import ipaddress\n\n# Parse network\nnetwork = ipaddress.ip_network('192.168.1.0/24')\nprint(f'Network: {network.network_address}')\nprint(f'Broadcast: {network.broadcast_address}')\nprint(f'Hosts: {list(network.hosts())[:5]}...')\nprint(f'Total hosts: {network.num_addresses - 2}')\n\n# Check if IP in network\nip = ipaddress.ip_address('192.168.1.100')\nprint(ip in network)  # True\n\n# Private IP check\nprint(ip.is_private)  # True",
        "bash": "# View network configuration\nip addr show\nifconfig\n\n# Calculate subnet\nipcalc 192.168.1.0/24\n\n# Check if host is reachable\nping -c 4 192.168.1.1"
      },
      "tips": [
        "Private ranges: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16",
        "IPv6 eliminates need for NAT with its vast address space",
        "Use CIDR calculators for complex subnetting"
      ]
    },
    {
      "id": "websockets",
      "title": "WebSockets",
      "symbol": "ðŸ”Œ",
      "level": "intermediate",
      "definition": {
        "text": "WebSockets provide full-duplex, bidirectional communication over a single TCP connection. Unlike HTTP's request-response model, WebSockets allow both client and server to send messages at any time. Ideal for real-time applications.",
        "keyTerms": ["Full-Duplex", "Persistent Connection", "ws://", "wss://", "Handshake", "Frame"]
      },
      "keyFormulas": [
        {
          "id": "ws_vs_http",
          "name": "WebSocket vs HTTP",
          "formula": "HTTP: Requestâ†’Response (half-duplex) | WebSocket: Bidirectional (full-duplex)",
          "latex": null,
          "meaning": "WebSockets maintain persistent connection"
        }
      ],
      "examples": [
        {
          "id": "ws_ex1",
          "question": "When to use WebSockets vs HTTP?",
          "steps": [
            {"step": 1, "action": "Need real-time updates?", "result": "WebSocket if yes", "explanation": "Server can push updates"},
            {"step": 2, "action": "Frequent small messages?", "result": "WebSocket more efficient", "explanation": "No HTTP overhead per message"},
            {"step": 3, "action": "Simple request-response?", "result": "HTTP is sufficient", "explanation": "Don't overcomplicate"}
          ],
          "finalAnswer": "Use WebSockets for real-time, bidirectional communication; HTTP for standard requests",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "Chat Applications", "description": "Real-time messaging"},
        {"title": "Live Dashboards", "description": "Stock prices, metrics"},
        {"title": "Multiplayer Games", "description": "Game state synchronization"},
        {"title": "Collaborative Tools", "description": "Google Docs-style editing"}
      ],
      "codeExample": {
        "python": "# Server (using websockets library)\nimport asyncio\nimport websockets\n\nasync def handler(websocket):\n    async for message in websocket:\n        print(f'Received: {message}')\n        await websocket.send(f'Echo: {message}')\n\nasync def main():\n    async with websockets.serve(handler, 'localhost', 8765):\n        await asyncio.Future()  # Run forever\n\nasyncio.run(main())",
        "javascript": "// Browser client\nconst ws = new WebSocket('wss://example.com/socket');\n\nws.onopen = () => {\n  console.log('Connected');\n  ws.send('Hello, server!');\n};\n\nws.onmessage = (event) => {\n  console.log('Received:', event.data);\n};\n\nws.onerror = (error) => {\n  console.error('Error:', error);\n};\n\nws.onclose = () => {\n  console.log('Disconnected');\n};"
      },
      "tips": [
        "Always use wss:// (TLS) in production",
        "Implement reconnection logic for dropped connections",
        "Consider Socket.IO for additional features (rooms, fallbacks)"
      ]
    },
    {
      "id": "rest_api",
      "title": "REST Architecture",
      "symbol": "ðŸ”—",
      "level": "intermediate",
      "definition": {
        "text": "REST (Representational State Transfer) is an architectural style for designing networked applications. RESTful APIs use HTTP methods to perform CRUD operations on resources identified by URLs. Key principles include statelessness, uniform interface, and resource-based design.",
        "keyTerms": ["Resource", "Endpoint", "Stateless", "CRUD", "HATEOAS", "Idempotent"]
      },
      "keyFormulas": [
        {
          "id": "rest_crud",
          "name": "REST CRUD Mapping",
          "formula": "Create=POST | Read=GET | Update=PUT/PATCH | Delete=DELETE",
          "latex": null,
          "meaning": "HTTP methods map to CRUD operations"
        }
      ],
      "examples": [
        {
          "id": "rest_ex1",
          "question": "Design RESTful endpoints for a blog API",
          "steps": [
            {"step": 1, "action": "List all posts", "result": "GET /api/posts", "explanation": "Collection resource"},
            {"step": 2, "action": "Get single post", "result": "GET /api/posts/:id", "explanation": "Individual resource"},
            {"step": 3, "action": "Create post", "result": "POST /api/posts", "explanation": "Create new resource"},
            {"step": 4, "action": "Get post comments", "result": "GET /api/posts/:id/comments", "explanation": "Nested resource"},
            {"step": 5, "action": "Delete comment", "result": "DELETE /api/posts/:id/comments/:commentId", "explanation": "Nested delete"}
          ],
          "finalAnswer": "Use nouns for resources, HTTP methods for actions, nest related resources",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "Web Services", "description": "Backend APIs for web/mobile apps"},
        {"title": "Microservices", "description": "Service-to-service communication"},
        {"title": "Third-Party APIs", "description": "Stripe, Twilio, GitHub APIs"},
        {"title": "IoT", "description": "Device communication"}
      ],
      "codeExample": {
        "python": "from flask import Flask, jsonify, request\n\napp = Flask(__name__)\n\n@app.route('/api/posts', methods=['GET'])\ndef list_posts():\n    return jsonify(posts)\n\n@app.route('/api/posts/<int:post_id>', methods=['GET'])\ndef get_post(post_id):\n    post = find_post(post_id)\n    if not post:\n        return jsonify({'error': 'Not found'}), 404\n    return jsonify(post)\n\n@app.route('/api/posts', methods=['POST'])\ndef create_post():\n    data = request.json\n    post = create_new_post(data)\n    return jsonify(post), 201",
        "javascript": "// Express.js\nconst express = require('express');\nconst app = express();\napp.use(express.json());\n\napp.get('/api/posts', (req, res) => {\n  res.json(posts);\n});\n\napp.post('/api/posts', (req, res) => {\n  const post = createPost(req.body);\n  res.status(201).json(post);\n});\n\napp.delete('/api/posts/:id', (req, res) => {\n  deletePost(req.params.id);\n  res.status(204).send();\n});"
      },
      "tips": [
        "Use plural nouns: /users not /user",
        "Return appropriate status codes",
        "Version your API: /api/v1/users"
      ]
    },
    {
      "id": "graphql",
      "title": "GraphQL",
      "symbol": "â—ˆ",
      "level": "intermediate",
      "definition": {
        "text": "GraphQL is a query language for APIs that lets clients request exactly the data they need. Unlike REST with fixed endpoints, GraphQL has a single endpoint where clients specify their data requirements. This reduces over-fetching and under-fetching of data.",
        "keyTerms": ["Query", "Mutation", "Schema", "Resolver", "Type", "Fragment", "Subscription"]
      },
      "keyFormulas": [
        {
          "id": "graphql_ops",
          "name": "GraphQL Operations",
          "formula": "Query (read) | Mutation (write) | Subscription (real-time)",
          "latex": null,
          "meaning": "Three types of operations"
        }
      ],
      "examples": [
        {
          "id": "gql_ex1",
          "question": "Fetch a user with their posts using GraphQL",
          "steps": [
            {"step": 1, "action": "Write query with fields", "result": "query { user(id: 1) { name posts { title } } }", "explanation": "Request specific fields"},
            {"step": 2, "action": "Send to single endpoint", "result": "POST /graphql", "explanation": "One endpoint for all queries"},
            {"step": 3, "action": "Receive exact data requested", "result": "{ user: { name: ..., posts: [...] } }", "explanation": "No over-fetching"}
          ],
          "finalAnswer": "GraphQL lets you request exactly what you need in a single request",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "Mobile Apps", "description": "Minimize data transfer"},
        {"title": "Complex UIs", "description": "Fetch data for multiple components"},
        {"title": "API Aggregation", "description": "Single endpoint for multiple services"},
        {"title": "GitHub API", "description": "GitHub's v4 API uses GraphQL"}
      ],
      "codeExample": {
        "javascript": "// GraphQL Query\nconst query = `\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      name\n      email\n      posts {\n        title\n        createdAt\n      }\n    }\n  }\n`;\n\n// Fetch\nconst response = await fetch('/graphql', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    query,\n    variables: { id: '1' }\n  })\n});\n\n// Mutation\nconst mutation = `\n  mutation CreatePost($input: PostInput!) {\n    createPost(input: $input) {\n      id\n      title\n    }\n  }\n`;"
      },
      "tips": [
        "Use fragments for reusable field selections",
        "Implement dataloader for N+1 query prevention",
        "REST is simpler for basic CRUD, GraphQL shines for complex queries"
      ]
    },
    {
      "id": "load_balancing",
      "title": "Load Balancing",
      "symbol": "âš–ï¸",
      "level": "intermediate",
      "definition": {
        "text": "Load balancing distributes incoming network traffic across multiple servers to ensure no single server bears too much load. This improves responsiveness, availability, and enables horizontal scaling. Common algorithms include round-robin, least connections, and IP hash.",
        "keyTerms": ["Load Balancer", "Round Robin", "Least Connections", "Health Check", "Session Affinity", "L4/L7"]
      },
      "keyFormulas": [
        {
          "id": "lb_algorithms",
          "name": "Load Balancing Algorithms",
          "formula": "Round Robin: Equal distribution | Least Connections: To least busy | IP Hash: Consistent routing",
          "latex": null,
          "meaning": "Different algorithms for different needs"
        }
      ],
      "examples": [
        {
          "id": "lb_ex1",
          "question": "How does health checking work in load balancing?",
          "steps": [
            {"step": 1, "action": "Load balancer sends periodic health checks", "result": "GET /health every 10s", "explanation": "Monitor server status"},
            {"step": 2, "action": "Server responds if healthy", "result": "200 OK", "explanation": "Server is working"},
            {"step": 3, "action": "Failed checks mark server unhealthy", "result": "Remove from rotation", "explanation": "No traffic to failed servers"},
            {"step": 4, "action": "Recovered server rejoins", "result": "Back in rotation", "explanation": "Automatic recovery"}
          ],
          "finalAnswer": "Health checks ensure traffic only goes to working servers",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "Web Applications", "description": "Distribute HTTP requests across servers"},
        {"title": "Database", "description": "Read replicas behind load balancer"},
        {"title": "Microservices", "description": "Service mesh load balancing"},
        {"title": "Global Distribution", "description": "GeoDNS + regional load balancers"}
      ],
      "codeExample": {
        "bash": "# Nginx load balancer configuration\nupstream backend {\n    least_conn;  # Algorithm\n    server 10.0.0.1:8080 weight=3;\n    server 10.0.0.2:8080;\n    server 10.0.0.3:8080 backup;\n}\n\nserver {\n    listen 80;\n    location / {\n        proxy_pass http://backend;\n        proxy_next_upstream error timeout http_503;\n    }\n}"
      },
      "tips": [
        "Use health checks to detect failed servers",
        "Consider sticky sessions for stateful applications",
        "L7 load balancing can route based on URL/headers"
      ]
    },
    {
      "id": "cdn",
      "title": "Content Delivery Networks (CDN)",
      "symbol": "ðŸŒ",
      "level": "intermediate",
      "definition": {
        "text": "A CDN is a geographically distributed network of servers that delivers content to users from the nearest location. CDNs cache static content (images, CSS, JS) at edge servers worldwide, reducing latency and origin server load.",
        "keyTerms": ["Edge Server", "PoP", "Cache", "Origin", "TTL", "Cache Invalidation", "Edge Computing"]
      },
      "keyFormulas": [
        {
          "id": "cdn_benefit",
          "name": "CDN Benefits",
          "formula": "Lower Latency + Reduced Origin Load + DDoS Protection + High Availability",
          "latex": null,
          "meaning": "Multiple benefits from edge distribution"
        }
      ],
      "examples": [
        {
          "id": "cdn_ex1",
          "question": "How does CDN caching work?",
          "steps": [
            {"step": 1, "action": "User requests resource", "result": "Request hits nearest edge server", "explanation": "Geographic routing"},
            {"step": 2, "action": "Cache hit", "result": "Return cached content immediately", "explanation": "No origin request needed"},
            {"step": 3, "action": "Cache miss", "result": "Edge fetches from origin, caches, returns", "explanation": "First request slower"},
            {"step": 4, "action": "TTL expires", "result": "Edge revalidates with origin", "explanation": "Fresh content"}
          ],
          "finalAnswer": "CDN serves cached content from edge, only fetching from origin on cache miss",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "Static Assets", "description": "Images, CSS, JavaScript files"},
        {"title": "Video Streaming", "description": "Netflix, YouTube use CDNs"},
        {"title": "Software Distribution", "description": "App downloads, updates"},
        {"title": "API Acceleration", "description": "Edge computing for APIs"}
      ],
      "codeExample": {
        "bash": "# Cache-Control headers for CDN\nCache-Control: public, max-age=31536000  # 1 year for versioned assets\nCache-Control: public, max-age=0, must-revalidate  # Always check\nCache-Control: private, no-store  # Don't cache\n\n# CloudFront invalidation\naws cloudfront create-invalidation \\\n  --distribution-id EDFDVBD632BHDS5 \\\n  --paths '/images/*' '/css/*'"
      },
      "tips": [
        "Version static assets (app.abc123.js) for long cache times",
        "Use Cache-Control headers to control CDN behavior",
        "Purge cache when deploying critical updates"
      ]
    },
    {
      "id": "network_security",
      "title": "Network Security Basics",
      "symbol": "ðŸ›¡ï¸",
      "level": "intermediate",
      "definition": {
        "text": "Network security protects networks and data from unauthorized access, attacks, and misuse. It includes firewalls for traffic filtering, encryption for data protection, VPNs for secure remote access, and various security protocols and practices.",
        "keyTerms": ["Firewall", "VPN", "TLS/SSL", "DDoS", "IDS/IPS", "Zero Trust", "Encryption"]
      },
      "keyFormulas": [
        {
          "id": "security_layers",
          "name": "Defense in Depth",
          "formula": "Perimeter + Network + Host + Application + Data = Layered Security",
          "latex": null,
          "meaning": "Multiple security layers provide better protection"
        }
      ],
      "examples": [
        {
          "id": "sec_ex1",
          "question": "What is a DDoS attack and how to mitigate?",
          "steps": [
            {"step": 1, "action": "Attackers flood server with traffic", "result": "Server overwhelmed", "explanation": "Distributed denial of service"},
            {"step": 2, "action": "Use CDN/DDoS protection", "result": "Edge absorbs traffic", "explanation": "Cloudflare, AWS Shield"},
            {"step": 3, "action": "Rate limiting", "result": "Block excessive requests", "explanation": "Limit per IP/session"},
            {"step": 4, "action": "Traffic analysis", "result": "Identify and block malicious patterns", "explanation": "ML-based detection"}
          ],
          "finalAnswer": "Mitigate DDoS with CDN, rate limiting, and traffic analysis",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "Corporate Networks", "description": "Firewall policies, VPN access"},
        {"title": "Cloud Security", "description": "Security groups, WAF"},
        {"title": "Web Applications", "description": "HTTPS, CORS, CSP headers"},
        {"title": "API Security", "description": "Authentication, rate limiting"}
      ],
      "codeExample": {
        "bash": "# iptables firewall rules\niptables -A INPUT -p tcp --dport 22 -j ACCEPT  # Allow SSH\niptables -A INPUT -p tcp --dport 80 -j ACCEPT  # Allow HTTP\niptables -A INPUT -p tcp --dport 443 -j ACCEPT  # Allow HTTPS\niptables -A INPUT -j DROP  # Drop all other\n\n# Nginx rate limiting\nlimit_req_zone $binary_remote_addr zone=api:10m rate=10r/s;\n\nserver {\n    location /api/ {\n        limit_req zone=api burst=20 nodelay;\n        proxy_pass http://backend;\n    }\n}"
      },
      "tips": [
        "Principle of least privilege - only allow necessary access",
        "Encrypt data in transit (TLS) and at rest",
        "Regular security audits and penetration testing"
      ]
    },
    {
      "id": "cors",
      "title": "CORS (Cross-Origin Resource Sharing)",
      "symbol": "ðŸ”“",
      "level": "intermediate",
      "definition": {
        "text": "CORS is a browser security feature that controls how web pages can request resources from different domains. By default, browsers block cross-origin requests to prevent security vulnerabilities. Servers must explicitly allow cross-origin access through CORS headers.",
        "keyTerms": ["Origin", "Preflight", "Access-Control-Allow-Origin", "Simple Request", "Credentials"]
      },
      "keyFormulas": [
        {
          "id": "cors_headers",
          "name": "CORS Headers",
          "formula": "Access-Control-Allow-Origin | Access-Control-Allow-Methods | Access-Control-Allow-Headers",
          "latex": null,
          "meaning": "Server headers that control CORS"
        }
      ],
      "examples": [
        {
          "id": "cors_ex1",
          "question": "Why does CORS preflight happen?",
          "steps": [
            {"step": 1, "action": "Browser sends OPTIONS request first", "result": "Preflight request", "explanation": "Check if server allows the actual request"},
            {"step": 2, "action": "Server responds with allowed methods/headers", "result": "CORS headers in response", "explanation": "Permission granted"},
            {"step": 3, "action": "Browser sends actual request", "result": "If preflight passed", "explanation": "Actual data request"},
            {"step": 4, "action": "When does preflight occur?", "result": "Non-simple requests", "explanation": "Custom headers, PUT/DELETE, JSON content-type"}
          ],
          "finalAnswer": "Preflight checks if server allows the cross-origin request before sending it",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "API Consumption", "description": "Frontend calling backend API"},
        {"title": "CDN", "description": "Loading assets from different domain"},
        {"title": "Third-Party APIs", "description": "External service integration"},
        {"title": "Microservices", "description": "Frontend gateway to multiple services"}
      ],
      "codeExample": {
        "python": "# Flask CORS\nfrom flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\nCORS(app, resources={\n    r'/api/*': {\n        'origins': ['https://example.com'],\n        'methods': ['GET', 'POST'],\n        'allow_headers': ['Content-Type', 'Authorization']\n    }\n})",
        "javascript": "// Express.js CORS\nconst cors = require('cors');\n\napp.use(cors({\n  origin: 'https://example.com',\n  methods: ['GET', 'POST', 'PUT', 'DELETE'],\n  allowedHeaders: ['Content-Type', 'Authorization'],\n  credentials: true\n}));\n\n// Or manual headers\napp.use((req, res, next) => {\n  res.header('Access-Control-Allow-Origin', 'https://example.com');\n  res.header('Access-Control-Allow-Methods', 'GET, POST');\n  next();\n});"
      },
      "tips": [
        "Never use Access-Control-Allow-Origin: * with credentials",
        "Preflight responses can be cached with Access-Control-Max-Age",
        "CORS is browser-enforced, not a server security measure"
      ]
    },
    {
      "id": "api_authentication",
      "title": "API Authentication Methods",
      "symbol": "ðŸ”‘",
      "level": "intermediate",
      "definition": {
        "text": "API authentication verifies the identity of clients making requests. Common methods include API keys (simple tokens), OAuth 2.0 (delegated authorization), and JWT (self-contained tokens). Each has different security properties and use cases.",
        "keyTerms": ["API Key", "OAuth 2.0", "JWT", "Bearer Token", "Session", "HMAC"]
      },
      "keyFormulas": [
        {
          "id": "auth_methods",
          "name": "Authentication Methods",
          "formula": "API Key: Simple | OAuth: Delegated | JWT: Stateless | Session: Stateful",
          "latex": null,
          "meaning": "Different methods for different needs"
        }
      ],
      "examples": [
        {
          "id": "auth_ex1",
          "question": "How does JWT authentication work?",
          "steps": [
            {"step": 1, "action": "User logs in with credentials", "result": "Server validates", "explanation": "Initial authentication"},
            {"step": 2, "action": "Server creates JWT with user info", "result": "Signed token returned", "explanation": "Token contains claims"},
            {"step": 3, "action": "Client stores and sends JWT", "result": "Authorization: Bearer <token>", "explanation": "Token in header"},
            {"step": 4, "action": "Server validates JWT signature", "result": "No database lookup needed", "explanation": "Stateless verification"}
          ],
          "finalAnswer": "JWT provides stateless authentication - server verifies signature without database",
          "difficulty": "intermediate"
        }
      ],
      "realWorldApplications": [
        {"title": "Mobile Apps", "description": "JWT for stateless auth"},
        {"title": "Third-Party APIs", "description": "API keys for rate limiting"},
        {"title": "Social Login", "description": "OAuth for 'Login with Google'"},
        {"title": "Microservices", "description": "Service-to-service auth"}
      ],
      "codeExample": {
        "python": "import jwt\nfrom datetime import datetime, timedelta\n\nSECRET = 'your-secret-key'\n\n# Create token\ndef create_token(user_id):\n    payload = {\n        'user_id': user_id,\n        'exp': datetime.utcnow() + timedelta(hours=24),\n        'iat': datetime.utcnow()\n    }\n    return jwt.encode(payload, SECRET, algorithm='HS256')\n\n# Verify token\ndef verify_token(token):\n    try:\n        payload = jwt.decode(token, SECRET, algorithms=['HS256'])\n        return payload['user_id']\n    except jwt.ExpiredSignatureError:\n        raise Exception('Token expired')\n    except jwt.InvalidTokenError:\n        raise Exception('Invalid token')",
        "javascript": "const jwt = require('jsonwebtoken');\n\nconst SECRET = 'your-secret-key';\n\n// Create token\nfunction createToken(userId) {\n  return jwt.sign(\n    { userId },\n    SECRET,\n    { expiresIn: '24h' }\n  );\n}\n\n// Middleware to verify\nfunction authMiddleware(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    const decoded = jwt.verify(token, SECRET);\n    req.userId = decoded.userId;\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Unauthorized' });\n  }\n}"
      },
      "tips": [
        "Store JWT in httpOnly cookies to prevent XSS",
        "Use short expiration times with refresh tokens",
        "API keys should be rotated regularly"
      ]
    }
  ]
}
