{
  "category": "CS Fundamentals",
  "categoryId": "cs_fundamentals",
  "version": "2.0.0",
  "description": "Core computer science concepts every engineer must understand",
  "icon": "cpu.fill",
  "color": "#4A90D9",
  "topics": [
    {
      "id": "what_is_os",
      "title": "What is an Operating System?",
      "symbol": "üñ•Ô∏è",
      "level": "beginner",
      "definition": {
        "text": "An Operating System (OS) is software that manages computer hardware and software resources and provides common services for computer programs. It acts as an intermediary between the user and the computer hardware, handling tasks like memory management, process scheduling, file systems, and device drivers.",
        "keyTerms": ["Kernel", "System Calls", "User Space", "Shell", "Device Drivers"]
      },
      "keyFormulas": [
        {
          "id": "os_layers",
          "name": "OS Layers",
          "formula": "User Apps ‚Üí Shell ‚Üí System Calls ‚Üí Kernel ‚Üí Hardware",
          "latex": null,
          "meaning": "How requests flow from user to hardware"
        }
      ],
      "examples": [
        {
          "id": "os_ex1",
          "question": "What happens when you double-click an app icon?",
          "steps": [
            {"step": 1, "action": "GUI sends signal to OS", "result": "Click event detected", "explanation": "The graphical shell captures your input"},
            {"step": 2, "action": "OS loads app into memory", "result": "App binary loaded", "explanation": "Kernel allocates memory for the program"},
            {"step": 3, "action": "OS creates a process", "result": "New PID assigned", "explanation": "Process gets a unique identifier"},
            {"step": 4, "action": "CPU starts executing", "result": "App window appears", "explanation": "Scheduler gives CPU time to the new process"}
          ],
          "finalAnswer": "The OS orchestrates loading, memory allocation, and process creation",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Windows, macOS, Linux", "description": "Desktop operating systems managing personal computers"},
        {"title": "Android & iOS", "description": "Mobile operating systems for smartphones"},
        {"title": "Cloud Servers", "description": "Linux servers running web applications"}
      ],
      "tips": [
        "The kernel is the core of the OS - everything else is built on top",
        "System calls are the API between user programs and the kernel",
        "Understanding OS concepts helps debug performance issues"
      ]
    },
    {
      "id": "processes_threads",
      "title": "Processes & Threads",
      "symbol": "‚öôÔ∏è",
      "level": "beginner",
      "definition": {
        "text": "A Process is an instance of a running program with its own memory space. A Thread is a lightweight unit of execution within a process that shares memory with other threads in the same process. Threads allow concurrent execution within a single process.",
        "keyTerms": ["Process", "Thread", "Concurrency", "Context Switch", "PID", "Stack", "Heap"]
      },
      "keyFormulas": [
        {
          "id": "process_thread",
          "name": "Process vs Thread",
          "formula": "Process = Code + Memory + Threads | Thread = Stack + Registers",
          "latex": null,
          "meaning": "Threads share process memory but have their own stack"
        }
      ],
      "examples": [
        {
          "id": "pt_ex1",
          "question": "Why would a web browser use multiple processes?",
          "steps": [
            {"step": 1, "action": "Each tab runs in separate process", "result": "Isolation achieved", "explanation": "One tab crashing doesn't kill others"},
            {"step": 2, "action": "Renderer, GPU, Network as separate processes", "result": "Better security", "explanation": "Malicious code is sandboxed"},
            {"step": 3, "action": "Multiple threads within each process", "result": "Parallel work", "explanation": "JS execution, rendering, network happen simultaneously"}
          ],
          "finalAnswer": "Multi-process architecture provides isolation and security while threads enable parallelism",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Web Servers", "description": "Handle multiple requests using threads or processes"},
        {"title": "Video Editing", "description": "Render different parts in parallel threads"},
        {"title": "Databases", "description": "Handle concurrent queries with thread pools"}
      ],
      "tips": [
        "Creating a thread is faster than creating a process",
        "Threads can cause race conditions if not synchronized",
        "Python has the GIL which limits true parallelism"
      ]
    },
    {
      "id": "memory_management",
      "title": "Memory Management",
      "symbol": "üíæ",
      "level": "intermediate",
      "definition": {
        "text": "Memory management is how the OS allocates, tracks, and reclaims memory for programs. It involves the stack (automatic, LIFO allocation for function calls), heap (dynamic allocation), virtual memory (abstraction giving each process its own address space), and paging (dividing memory into fixed-size blocks).",
        "keyTerms": ["Stack", "Heap", "Virtual Memory", "Paging", "Memory Leak", "Garbage Collection", "Segmentation Fault"]
      },
      "keyFormulas": [
        {
          "id": "mem_layout",
          "name": "Process Memory Layout",
          "formula": "High Address: Stack ‚Üì | Heap ‚Üë | BSS | Data | Text :Low Address",
          "latex": null,
          "meaning": "Stack grows down, heap grows up in process memory"
        }
      ],
      "examples": [
        {
          "id": "mem_ex1",
          "question": "What causes a stack overflow?",
          "steps": [
            {"step": 1, "action": "Function calls itself recursively", "result": "Each call adds stack frame", "explanation": "Stack grows toward heap"},
            {"step": 2, "action": "Stack exceeds its allocated size", "result": "Hits stack limit", "explanation": "Typical stack size is 1-8MB"},
            {"step": 3, "action": "OS detects boundary violation", "result": "Stack Overflow error", "explanation": "Program terminates to prevent corruption"}
          ],
          "finalAnswer": "Infinite recursion or very deep call stacks can exhaust stack memory",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Game Development", "description": "Memory pools for frequent allocations"},
        {"title": "Embedded Systems", "description": "Manual memory management with limited RAM"},
        {"title": "High-Performance Apps", "description": "Custom allocators to avoid fragmentation"}
      ],
      "codeExample": {
        "python": "# Python handles memory automatically\ndata = [1, 2, 3]  # Allocated on heap\ndel data  # Garbage collector frees memory",
        "javascript": "// JavaScript uses garbage collection\nlet obj = { name: 'test' };\nobj = null;  // Previous object eligible for GC"
      },
      "tips": [
        "Stack allocation is faster than heap allocation",
        "Memory leaks happen when heap memory isn't freed",
        "Use profilers to detect memory issues in production"
      ]
    },
    {
      "id": "arrays",
      "title": "Arrays",
      "symbol": "[]",
      "level": "beginner",
      "definition": {
        "text": "An Array is a data structure that stores elements in contiguous memory locations. Each element can be accessed directly using its index. Arrays have O(1) access time but O(n) insertion/deletion for arbitrary positions.",
        "keyTerms": ["Index", "Contiguous Memory", "Random Access", "Static Array", "Dynamic Array"]
      },
      "keyFormulas": [
        {
          "id": "array_access",
          "name": "Time Complexity",
          "formula": "Access: O(1) | Search: O(n) | Insert/Delete: O(n)",
          "latex": null,
          "meaning": "Arrays excel at direct access but struggle with modifications"
        },
        {
          "id": "array_memory",
          "name": "Memory Address",
          "formula": "address = base_address + (index √ó element_size)",
          "latex": null,
          "meaning": "How array elements are located in memory"
        }
      ],
      "examples": [
        {
          "id": "arr_ex1",
          "question": "Access element at index 3 in array [10, 20, 30, 40, 50]",
          "steps": [
            {"step": 1, "action": "Array starts at memory address 1000", "result": "Base address = 1000", "explanation": "Each int takes 4 bytes"},
            {"step": 2, "action": "Calculate offset: 3 √ó 4 = 12", "result": "Offset = 12 bytes", "explanation": "Skip first 3 elements"},
            {"step": 3, "action": "Access address 1000 + 12 = 1012", "result": "Value = 40", "explanation": "Direct memory access"}
          ],
          "finalAnswer": "array[3] = 40 (accessed in O(1) time)",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Image Processing", "description": "Pixels stored as 2D arrays"},
        {"title": "Game Development", "description": "Grid-based maps, inventory systems"},
        {"title": "Time Series Data", "description": "Stock prices, sensor readings"}
      ],
      "codeExample": {
        "python": "# Python list (dynamic array)\narr = [10, 20, 30, 40, 50]\nprint(arr[3])  # 40\narr.append(60)  # O(1) amortized",
        "javascript": "// JavaScript array\nconst arr = [10, 20, 30, 40, 50];\nconsole.log(arr[3]);  // 40\narr.push(60);"
      },
      "tips": [
        "Use arrays when you need fast random access",
        "Python lists are dynamic arrays under the hood",
        "Pre-allocate size if you know the final length"
      ]
    },
    {
      "id": "linked_lists",
      "title": "Linked Lists",
      "symbol": "üîó",
      "level": "beginner",
      "definition": {
        "text": "A Linked List is a data structure where elements (nodes) are connected via pointers. Each node contains data and a reference to the next node. Unlike arrays, linked lists don't require contiguous memory, making insertions and deletions O(1) at known positions.",
        "keyTerms": ["Node", "Head", "Tail", "Singly Linked", "Doubly Linked", "Pointer"]
      },
      "keyFormulas": [
        {
          "id": "ll_complexity",
          "name": "Time Complexity",
          "formula": "Access: O(n) | Search: O(n) | Insert/Delete at head: O(1)",
          "latex": null,
          "meaning": "Trade-off: slower access but faster modifications"
        }
      ],
      "examples": [
        {
          "id": "ll_ex1",
          "question": "Insert a node at the beginning of a linked list",
          "steps": [
            {"step": 1, "action": "Create new node with data", "result": "Node created", "explanation": "Allocate memory for new node"},
            {"step": 2, "action": "Point new node's next to current head", "result": "New ‚Üí Old Head", "explanation": "Link to existing list"},
            {"step": 3, "action": "Update head to new node", "result": "Head = New Node", "explanation": "O(1) operation complete"}
          ],
          "finalAnswer": "Inserting at head is O(1) because we only modify pointers",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Undo/Redo", "description": "Each action links to previous state"},
        {"title": "Music Playlists", "description": "Songs linked in play order"},
        {"title": "Browser History", "description": "Back/forward navigation"}
      ],
      "codeExample": {
        "python": "class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def insert_at_head(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node",
        "javascript": "class Node {\n  constructor(data) {\n    this.data = data;\n    this.next = null;\n  }\n}\n\nclass LinkedList {\n  constructor() {\n    this.head = null;\n  }\n}"
      },
      "tips": [
        "Use linked lists when you need frequent insertions/deletions",
        "Arrays are better for random access patterns",
        "Doubly linked lists allow O(1) deletion of any node"
      ]
    },
    {
      "id": "stacks_queues",
      "title": "Stacks & Queues",
      "symbol": "üìö",
      "level": "beginner",
      "definition": {
        "text": "A Stack is a LIFO (Last In, First Out) data structure where elements are added and removed from the same end (top). A Queue is a FIFO (First In, First Out) structure where elements are added at the rear and removed from the front.",
        "keyTerms": ["LIFO", "FIFO", "Push", "Pop", "Enqueue", "Dequeue", "Priority Queue"]
      },
      "keyFormulas": [
        {
          "id": "stack_queue_ops",
          "name": "Operations",
          "formula": "Stack: push(O(1)), pop(O(1)) | Queue: enqueue(O(1)), dequeue(O(1))",
          "latex": null,
          "meaning": "Both structures have constant time operations"
        }
      ],
      "examples": [
        {
          "id": "sq_ex1",
          "question": "Check if parentheses are balanced: '([{}])'",
          "steps": [
            {"step": 1, "action": "Push '(' onto stack", "result": "Stack: ['(']", "explanation": "Opening bracket"},
            {"step": 2, "action": "Push '[' onto stack", "result": "Stack: ['(', '[']", "explanation": "Another opening"},
            {"step": 3, "action": "Push '{' onto stack", "result": "Stack: ['(', '[', '{']", "explanation": "Third opening"},
            {"step": 4, "action": "Pop for '}' - matches '{'", "result": "Stack: ['(', '[']", "explanation": "Matching pair"},
            {"step": 5, "action": "Continue popping for ']' and ')'", "result": "Stack: []", "explanation": "All matched"}
          ],
          "finalAnswer": "Empty stack means balanced parentheses",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Call Stack", "description": "Function calls use a stack structure"},
        {"title": "Print Queue", "description": "Documents printed in order received"},
        {"title": "Task Scheduling", "description": "CPU scheduler uses queues"}
      ],
      "codeExample": {
        "python": "# Stack using list\nstack = []\nstack.append(1)  # push\nstack.pop()      # pop\n\n# Queue using deque\nfrom collections import deque\nqueue = deque()\nqueue.append(1)    # enqueue\nqueue.popleft()    # dequeue",
        "javascript": "// Stack\nconst stack = [];\nstack.push(1);\nstack.pop();\n\n// Queue\nconst queue = [];\nqueue.push(1);    // enqueue\nqueue.shift();    // dequeue"
      },
      "tips": [
        "Use stacks for recursion simulation, parsing, undo operations",
        "Use queues for BFS, task scheduling, buffering",
        "Python's deque is more efficient for queue operations than list"
      ]
    },
    {
      "id": "hash_tables",
      "title": "Hash Tables",
      "symbol": "#Ô∏è‚É£",
      "level": "intermediate",
      "definition": {
        "text": "A Hash Table (or Hash Map) is a data structure that stores key-value pairs using a hash function to compute an index into an array of buckets. It provides O(1) average case time complexity for insertion, deletion, and lookup operations.",
        "keyTerms": ["Hash Function", "Collision", "Bucket", "Load Factor", "Chaining", "Open Addressing"]
      },
      "keyFormulas": [
        {
          "id": "hash_complexity",
          "name": "Time Complexity",
          "formula": "Average: O(1) for insert/delete/search | Worst: O(n) with collisions",
          "latex": null,
          "meaning": "Hash tables are fast when the hash function distributes keys well"
        },
        {
          "id": "hash_index",
          "name": "Index Calculation",
          "formula": "index = hash(key) % array_size",
          "latex": null,
          "meaning": "Hash value is mapped to array index using modulo"
        }
      ],
      "examples": [
        {
          "id": "hash_ex1",
          "question": "Store user 'alice' with age 25 in a hash table of size 10",
          "steps": [
            {"step": 1, "action": "Calculate hash('alice')", "result": "Hash = 52847", "explanation": "Hash function produces integer"},
            {"step": 2, "action": "Calculate index: 52847 % 10", "result": "Index = 7", "explanation": "Map to array position"},
            {"step": 3, "action": "Store at index 7", "result": "table[7] = ('alice', 25)", "explanation": "Key-value pair stored"}
          ],
          "finalAnswer": "User 'alice' stored at index 7 with O(1) time",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Caching", "description": "Redis, Memcached store key-value pairs"},
        {"title": "Database Indexes", "description": "Fast lookups by primary key"},
        {"title": "Symbol Tables", "description": "Compilers store variable names"}
      ],
      "codeExample": {
        "python": "# Python dictionary (hash table)\nuser = {'name': 'alice', 'age': 25}\nprint(user['name'])  # O(1) lookup\nuser['email'] = 'alice@example.com'  # O(1) insert",
        "javascript": "// JavaScript object/Map\nconst user = { name: 'alice', age: 25 };\nconsole.log(user.name);  // O(1)\n// Or use Map for better performance\nconst map = new Map();\nmap.set('key', 'value');"
      },
      "tips": [
        "Choose a good hash function to minimize collisions",
        "Load factor above 0.7 typically triggers resize",
        "In Python, dicts are ordered since Python 3.7"
      ]
    },
    {
      "id": "trees",
      "title": "Trees & Binary Trees",
      "symbol": "üå≥",
      "level": "intermediate",
      "definition": {
        "text": "A Tree is a hierarchical data structure with a root node and subtrees of children nodes. A Binary Tree is a tree where each node has at most two children (left and right). Trees are used for hierarchical data, searching, and sorting.",
        "keyTerms": ["Root", "Leaf", "Parent", "Child", "Height", "Depth", "Binary Tree", "BST"]
      },
      "keyFormulas": [
        {
          "id": "tree_properties",
          "name": "Binary Tree Properties",
          "formula": "Max nodes at level h = 2^h | Max total nodes = 2^(h+1) - 1",
          "latex": null,
          "meaning": "Number of nodes grows exponentially with height"
        }
      ],
      "examples": [
        {
          "id": "tree_ex1",
          "question": "Traverse a binary tree in order: [4, 2, 5, 1, 3]",
          "steps": [
            {"step": 1, "action": "Go to leftmost node", "result": "Visit 1", "explanation": "In-order: left, root, right"},
            {"step": 2, "action": "Visit parent of 1", "result": "Visit 2", "explanation": "After left subtree, visit root"},
            {"step": 3, "action": "Visit right subtree of 2", "result": "Visit 3", "explanation": "Complete subtree"},
            {"step": 4, "action": "Continue up and right", "result": "Visit 4, then 5", "explanation": "Finish traversal"}
          ],
          "finalAnswer": "In-order traversal: 1, 2, 3, 4, 5 (sorted for BST)",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "File Systems", "description": "Directory hierarchy is a tree"},
        {"title": "DOM", "description": "HTML document object model"},
        {"title": "Databases", "description": "B-trees for indexing"}
      ],
      "codeExample": {
        "python": "class TreeNode:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n\ndef inorder(node):\n    if node:\n        inorder(node.left)\n        print(node.val)\n        inorder(node.right)",
        "javascript": "class TreeNode {\n  constructor(val) {\n    this.val = val;\n    this.left = null;\n    this.right = null;\n  }\n}"
      },
      "tips": [
        "BST allows O(log n) search if balanced",
        "Use recursion for tree traversals",
        "Self-balancing trees (AVL, Red-Black) maintain O(log n) operations"
      ]
    },
    {
      "id": "graphs",
      "title": "Graphs",
      "symbol": "üï∏Ô∏è",
      "level": "intermediate",
      "definition": {
        "text": "A Graph is a data structure consisting of vertices (nodes) and edges connecting them. Graphs can be directed (edges have direction) or undirected, and weighted (edges have values) or unweighted. They model networks, relationships, and connections.",
        "keyTerms": ["Vertex", "Edge", "Directed", "Undirected", "Weighted", "Adjacency List", "Adjacency Matrix"]
      },
      "keyFormulas": [
        {
          "id": "graph_storage",
          "name": "Storage Complexity",
          "formula": "Adjacency List: O(V+E) | Adjacency Matrix: O(V¬≤)",
          "latex": null,
          "meaning": "Choose representation based on graph density"
        }
      ],
      "examples": [
        {
          "id": "graph_ex1",
          "question": "Find all nodes reachable from node A using BFS",
          "steps": [
            {"step": 1, "action": "Add A to queue, mark visited", "result": "Queue: [A], Visited: {A}", "explanation": "Start BFS"},
            {"step": 2, "action": "Dequeue A, add neighbors B, C", "result": "Queue: [B, C]", "explanation": "Explore neighbors"},
            {"step": 3, "action": "Continue until queue empty", "result": "All reachable nodes found", "explanation": "BFS explores level by level"}
          ],
          "finalAnswer": "BFS finds all reachable nodes in O(V+E) time",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Social Networks", "description": "Users as nodes, friendships as edges"},
        {"title": "Maps/Navigation", "description": "Roads connecting locations"},
        {"title": "Dependency Management", "description": "Package dependencies"}
      ],
      "codeExample": {
        "python": "from collections import deque\n\ndef bfs(graph, start):\n    visited = set([start])\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        print(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)",
        "javascript": "function bfs(graph, start) {\n  const visited = new Set([start]);\n  const queue = [start];\n  while (queue.length) {\n    const node = queue.shift();\n    for (const neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n}"
      },
      "tips": [
        "Use BFS for shortest path in unweighted graphs",
        "Use DFS for exploring all paths, cycle detection",
        "Dijkstra's algorithm for weighted shortest path"
      ]
    },
    {
      "id": "algorithm_complexity",
      "title": "Big O Notation",
      "symbol": "O(n)",
      "level": "intermediate",
      "definition": {
        "text": "Big O Notation describes the upper bound of an algorithm's time or space complexity in terms of input size. It tells us how an algorithm's performance scales as the input grows, ignoring constants and lower-order terms.",
        "keyTerms": ["Time Complexity", "Space Complexity", "Worst Case", "Average Case", "Asymptotic Analysis"]
      },
      "keyFormulas": [
        {
          "id": "common_complexities",
          "name": "Common Complexities",
          "formula": "O(1) < O(log n) < O(n) < O(n log n) < O(n¬≤) < O(2‚Åø) < O(n!)",
          "latex": null,
          "meaning": "From fastest to slowest growth rate"
        }
      ],
      "examples": [
        {
          "id": "bigo_ex1",
          "question": "What's the time complexity of finding max in an unsorted array?",
          "steps": [
            {"step": 1, "action": "Must check every element", "result": "n comparisons needed", "explanation": "Can't skip any element"},
            {"step": 2, "action": "Double the input size", "result": "Double the comparisons", "explanation": "Linear relationship"},
            {"step": 3, "action": "Classify the growth", "result": "O(n)", "explanation": "Time grows linearly with input"}
          ],
          "finalAnswer": "O(n) - Linear time complexity",
          "difficulty": "easy"
        },
        {
          "id": "bigo_ex2",
          "question": "What's the complexity of nested loops iterating over same array?",
          "steps": [
            {"step": 1, "action": "Outer loop runs n times", "result": "n iterations", "explanation": "First loop"},
            {"step": 2, "action": "Inner loop runs n times for each outer", "result": "n √ó n = n¬≤ operations", "explanation": "Multiplication of loops"},
            {"step": 3, "action": "Total work", "result": "O(n¬≤)", "explanation": "Quadratic complexity"}
          ],
          "finalAnswer": "O(n¬≤) - Quadratic time complexity",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Algorithm Selection", "description": "Choose efficient algorithms for large datasets"},
        {"title": "Code Review", "description": "Identify performance bottlenecks"},
        {"title": "System Design", "description": "Estimate server requirements"}
      ],
      "tips": [
        "Focus on the dominant term - drop constants and lower terms",
        "O(n log n) is typically the best for comparison-based sorting",
        "Space complexity matters for memory-constrained environments"
      ]
    },
    {
      "id": "sorting_algorithms",
      "title": "Sorting Algorithms",
      "symbol": "üî¢",
      "level": "intermediate",
      "definition": {
        "text": "Sorting algorithms arrange elements in a specific order (ascending/descending). Common algorithms include QuickSort (divide and conquer, O(n log n) average), MergeSort (stable, O(n log n) always), and BubbleSort (simple but O(n¬≤)).",
        "keyTerms": ["QuickSort", "MergeSort", "BubbleSort", "Stable Sort", "In-place", "Divide and Conquer"]
      },
      "keyFormulas": [
        {
          "id": "sort_complexity",
          "name": "Sorting Complexities",
          "formula": "QuickSort: O(n log n) avg | MergeSort: O(n log n) | BubbleSort: O(n¬≤)",
          "latex": null,
          "meaning": "Choose based on data characteristics and requirements"
        }
      ],
      "examples": [
        {
          "id": "sort_ex1",
          "question": "Sort [3, 1, 4, 1, 5] using QuickSort",
          "steps": [
            {"step": 1, "action": "Choose pivot (e.g., 4)", "result": "Pivot = 4", "explanation": "Partition around pivot"},
            {"step": 2, "action": "Partition: elements < 4 left, >= 4 right", "result": "[3,1,1] [4] [5]", "explanation": "Pivot in correct position"},
            {"step": 3, "action": "Recursively sort subarrays", "result": "[1,1,3] [4] [5]", "explanation": "Apply same process"},
            {"step": 4, "action": "Combine", "result": "[1,1,3,4,5]", "explanation": "Sorted array"}
          ],
          "finalAnswer": "QuickSort achieves O(n log n) average case through divide and conquer",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Database Queries", "description": "ORDER BY uses sorting"},
        {"title": "Search Engines", "description": "Rank results by relevance"},
        {"title": "E-commerce", "description": "Sort products by price, rating"}
      ],
      "codeExample": {
        "python": "# Python's built-in sort uses Timsort\narr = [3, 1, 4, 1, 5]\narr.sort()  # In-place\nsorted_arr = sorted(arr)  # Returns new list\n\n# Custom sort\nusers.sort(key=lambda x: x['age'])",
        "javascript": "// JavaScript sort (modifies in place)\nconst arr = [3, 1, 4, 1, 5];\narr.sort((a, b) => a - b);  // Ascending\n\n// Sort objects\nusers.sort((a, b) => a.age - b.age);"
      },
      "tips": [
        "Use built-in sort functions - they're highly optimized",
        "QuickSort is often fastest in practice despite O(n¬≤) worst case",
        "MergeSort is stable and predictable - good for linked lists"
      ]
    },
    {
      "id": "searching_algorithms",
      "title": "Searching Algorithms",
      "symbol": "üîç",
      "level": "beginner",
      "definition": {
        "text": "Searching algorithms find elements in data structures. Linear Search checks each element O(n). Binary Search repeatedly divides sorted data in half O(log n). Hash-based search provides O(1) average time.",
        "keyTerms": ["Linear Search", "Binary Search", "Hash Lookup", "Sorted Array", "Search Space"]
      },
      "keyFormulas": [
        {
          "id": "search_complexity",
          "name": "Search Complexities",
          "formula": "Linear: O(n) | Binary: O(log n) | Hash: O(1) average",
          "latex": null,
          "meaning": "Binary search requires sorted data but is much faster"
        }
      ],
      "examples": [
        {
          "id": "search_ex1",
          "question": "Find 23 in sorted array [2, 5, 8, 12, 16, 23, 38, 56, 72, 91]",
          "steps": [
            {"step": 1, "action": "Check middle element (16)", "result": "23 > 16, search right half", "explanation": "Eliminate left half"},
            {"step": 2, "action": "Check middle of right half (38)", "result": "23 < 38, search left", "explanation": "Eliminate right portion"},
            {"step": 3, "action": "Check next middle (23)", "result": "Found at index 5", "explanation": "Match found"}
          ],
          "finalAnswer": "Binary search found 23 in 3 steps instead of 6 with linear search",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Dictionary Lookup", "description": "Binary search in sorted word lists"},
        {"title": "Database Queries", "description": "B-tree indexes use binary search"},
        {"title": "Version Control", "description": "Git bisect finds buggy commits"}
      ],
      "codeExample": {
        "python": "def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1",
        "javascript": "function binarySearch(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) left = mid + 1;\n    else right = mid - 1;\n  }\n  return -1;\n}"
      },
      "tips": [
        "Always use binary search on sorted data",
        "Use bisect module in Python for binary search",
        "Binary search can solve many 'find minimum/maximum' problems"
      ]
    },
    {
      "id": "recursion",
      "title": "Recursion",
      "symbol": "üîÑ",
      "level": "intermediate",
      "definition": {
        "text": "Recursion is when a function calls itself to solve smaller instances of the same problem. Every recursive function needs a base case (stopping condition) and a recursive case. It's powerful for tree traversals, divide-and-conquer algorithms, and mathematical functions.",
        "keyTerms": ["Base Case", "Recursive Case", "Call Stack", "Stack Overflow", "Tail Recursion"]
      },
      "keyFormulas": [
        {
          "id": "recursion_formula",
          "name": "Recursion Template",
          "formula": "if base_case: return result | else: return f(smaller_problem)",
          "latex": null,
          "meaning": "Every recursion needs termination condition and progress toward it"
        }
      ],
      "examples": [
        {
          "id": "rec_ex1",
          "question": "Calculate factorial of 5 recursively",
          "steps": [
            {"step": 1, "action": "factorial(5) = 5 √ó factorial(4)", "result": "5 √ó ?", "explanation": "Recursive call"},
            {"step": 2, "action": "factorial(4) = 4 √ó factorial(3)", "result": "4 √ó 3 √ó 2 √ó 1", "explanation": "Chain continues"},
            {"step": 3, "action": "factorial(1) = 1", "result": "Base case reached", "explanation": "Stop recursion"},
            {"step": 4, "action": "Unwind: 1 √ó 2 √ó 3 √ó 4 √ó 5", "result": "120", "explanation": "Calculate result"}
          ],
          "finalAnswer": "5! = 120",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "File System Traversal", "description": "Recursively list all files in directories"},
        {"title": "JSON Parsing", "description": "Handle nested objects/arrays"},
        {"title": "Tree Operations", "description": "Traverse, search, modify trees"}
      ],
      "codeExample": {
        "python": "def factorial(n):\n    if n <= 1:  # Base case\n        return 1\n    return n * factorial(n - 1)  # Recursive case\n\ndef fibonacci(n):\n    if n <= 1:\n        return n\n    return fibonacci(n-1) + fibonacci(n-2)",
        "javascript": "function factorial(n) {\n  if (n <= 1) return 1;\n  return n * factorial(n - 1);\n}\n\nfunction fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n-1) + fibonacci(n-2);\n}"
      },
      "tips": [
        "Always define the base case first",
        "Each recursive call should make progress toward base case",
        "Consider memoization for overlapping subproblems"
      ]
    },
    {
      "id": "dynamic_programming",
      "title": "Dynamic Programming",
      "symbol": "üìä",
      "level": "advanced",
      "definition": {
        "text": "Dynamic Programming (DP) is an optimization technique that solves complex problems by breaking them into overlapping subproblems and storing their solutions. It avoids redundant calculations through memoization (top-down) or tabulation (bottom-up).",
        "keyTerms": ["Memoization", "Tabulation", "Overlapping Subproblems", "Optimal Substructure", "State Transition"]
      },
      "keyFormulas": [
        {
          "id": "dp_approach",
          "name": "DP Approaches",
          "formula": "Top-Down (Memoization): Recursive + Cache | Bottom-Up (Tabulation): Iterative + Table",
          "latex": null,
          "meaning": "Two ways to implement dynamic programming"
        }
      ],
      "examples": [
        {
          "id": "dp_ex1",
          "question": "Calculate Fibonacci(6) using DP",
          "steps": [
            {"step": 1, "action": "Initialize table: [0, 1, ?, ?, ?, ?, ?]", "result": "Base cases set", "explanation": "F(0)=0, F(1)=1"},
            {"step": 2, "action": "F(2) = F(1) + F(0) = 1", "result": "[0,1,1,?,?,?,?]", "explanation": "Build up"},
            {"step": 3, "action": "Continue: F(3)=2, F(4)=3, F(5)=5, F(6)=8", "result": "[0,1,1,2,3,5,8]", "explanation": "Each uses previous values"}
          ],
          "finalAnswer": "F(6) = 8, computed in O(n) time instead of O(2^n)",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Route Optimization", "description": "Shortest path algorithms"},
        {"title": "Text Diff", "description": "Git diff uses longest common subsequence"},
        {"title": "Resource Allocation", "description": "Knapsack problem for budgeting"}
      ],
      "codeExample": {
        "python": "# Memoization (top-down)\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fib_memo(n):\n    if n <= 1:\n        return n\n    return fib_memo(n-1) + fib_memo(n-2)\n\n# Tabulation (bottom-up)\ndef fib_tab(n):\n    if n <= 1:\n        return n\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i-1] + dp[i-2]\n    return dp[n]",
        "javascript": "// Memoization\nfunction fibMemo(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  memo[n] = fibMemo(n-1, memo) + fibMemo(n-2, memo);\n  return memo[n];\n}"
      },
      "tips": [
        "Identify if problem has overlapping subproblems",
        "Define state clearly - what parameters define a subproblem",
        "Write recurrence relation before coding"
      ]
    },
    {
      "id": "design_patterns",
      "title": "Design Patterns",
      "symbol": "üìê",
      "level": "advanced",
      "definition": {
        "text": "Design Patterns are reusable solutions to common software design problems. They are templates for solving recurring design challenges and improve code maintainability, flexibility, and communication among developers. The Gang of Four (GoF) categorized them into Creational, Structural, and Behavioral patterns.",
        "keyTerms": ["Singleton", "Factory", "Observer", "Strategy", "Dependency Injection", "Adapter"]
      },
      "keyFormulas": [
        {
          "id": "pattern_categories",
          "name": "Pattern Categories",
          "formula": "Creational (create) | Structural (compose) | Behavioral (communicate)",
          "latex": null,
          "meaning": "Three main categories of design patterns"
        }
      ],
      "examples": [
        {
          "id": "dp_ex1",
          "question": "When should you use the Singleton pattern?",
          "steps": [
            {"step": 1, "action": "Need exactly one instance", "result": "Database connection, Logger", "explanation": "Shared resource management"},
            {"step": 2, "action": "Global access point needed", "result": "Configuration, Cache", "explanation": "Access from anywhere"},
            {"step": 3, "action": "Lazy initialization desired", "result": "Create when first needed", "explanation": "Defer expensive creation"}
          ],
          "finalAnswer": "Use Singleton for shared resources needing exactly one instance",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Factory Pattern", "description": "Creating objects without specifying exact class (React.createElement)"},
        {"title": "Observer Pattern", "description": "Event systems, pub/sub (React state updates)"},
        {"title": "Strategy Pattern", "description": "Swappable algorithms (payment methods)"}
      ],
      "codeExample": {
        "python": "# Singleton Pattern\nclass Database:\n    _instance = None\n    \n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n        return cls._instance\n\n# Factory Pattern\nclass NotificationFactory:\n    @staticmethod\n    def create(type):\n        if type == 'email':\n            return EmailNotification()\n        elif type == 'sms':\n            return SMSNotification()",
        "javascript": "// Singleton Pattern\nclass Database {\n  static instance;\n  static getInstance() {\n    if (!Database.instance) {\n      Database.instance = new Database();\n    }\n    return Database.instance;\n  }\n}"
      },
      "tips": [
        "Don't overuse patterns - add complexity only when needed",
        "Singleton can make testing difficult - consider dependency injection",
        "Composition over inheritance - prefer Strategy over subclassing"
      ]
    },
    {
      "id": "binary_representation",
      "title": "Binary & Bitwise Operations",
      "symbol": "üî¢",
      "level": "intermediate",
      "definition": {
        "text": "Computers store and process data in binary (base-2) format. Bitwise operations manipulate individual bits and are extremely fast. Understanding binary is essential for systems programming, networking, and optimization.",
        "keyTerms": ["Binary", "Bit", "Byte", "AND", "OR", "XOR", "NOT", "Shift", "Two's Complement"]
      },
      "keyFormulas": [
        {
          "id": "bitwise_ops",
          "name": "Bitwise Operations",
          "formula": "AND(&): 1&1=1 | OR(|): 0|1=1 | XOR(^): 1^1=0 | NOT(~): ~0=1",
          "latex": null,
          "meaning": "Basic bitwise operations on bits"
        }
      ],
      "examples": [
        {
          "id": "binary_ex1",
          "question": "Check if a number is even using bitwise operations",
          "steps": [
            {"step": 1, "action": "Even numbers end in 0 in binary", "result": "4 = 100, 6 = 110, 8 = 1000", "explanation": "Last bit is 0"},
            {"step": 2, "action": "Use AND with 1 to get last bit", "result": "n & 1", "explanation": "Isolate rightmost bit"},
            {"step": 3, "action": "If result is 0, number is even", "result": "4 & 1 = 0", "explanation": "Even check: O(1)"}
          ],
          "finalAnswer": "n & 1 == 0 checks if n is even in constant time",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Permissions", "description": "Unix file permissions use bit flags"},
        {"title": "Graphics", "description": "Color values manipulated with bitwise ops"},
        {"title": "Cryptography", "description": "XOR used in encryption algorithms"}
      ],
      "codeExample": {
        "python": "# Check if even\nis_even = (n & 1) == 0\n\n# Multiply by 2 (left shift)\ndoubled = n << 1\n\n# Divide by 2 (right shift)\nhalved = n >> 1\n\n# Toggle bit at position\ntoggled = n ^ (1 << position)",
        "javascript": "// Check if even\nconst isEven = (n & 1) === 0;\n\n// Multiply/divide by powers of 2\nconst doubled = n << 1;\nconst halved = n >> 1;\n\n// Set bit at position\nconst setBit = n | (1 << position);"
      },
      "tips": [
        "Bitwise operations are faster than arithmetic equivalents",
        "XOR is useful for swapping without temp variable",
        "Left shift by n = multiply by 2^n"
      ]
    },
    {
      "id": "concurrency",
      "title": "Concurrency & Parallelism",
      "symbol": "üîÄ",
      "level": "advanced",
      "definition": {
        "text": "Concurrency is dealing with multiple tasks that can start, run, and complete in overlapping time periods. Parallelism is actually executing multiple tasks simultaneously on multiple processors. Understanding both is crucial for building responsive and efficient applications.",
        "keyTerms": ["Concurrency", "Parallelism", "Race Condition", "Deadlock", "Mutex", "Semaphore", "Async/Await"]
      },
      "keyFormulas": [
        {
          "id": "concurrency_vs_parallelism",
          "name": "Concurrency vs Parallelism",
          "formula": "Concurrency: Structure | Parallelism: Execution | Concurrent ‚â† Parallel",
          "latex": null,
          "meaning": "Concurrency is about design, parallelism is about execution"
        }
      ],
      "examples": [
        {
          "id": "conc_ex1",
          "question": "What causes a race condition?",
          "steps": [
            {"step": 1, "action": "Two threads read shared variable", "result": "Both read value = 0", "explanation": "Concurrent reads"},
            {"step": 2, "action": "Both increment their local copy", "result": "Both have value = 1", "explanation": "Local computation"},
            {"step": 3, "action": "Both write back to shared variable", "result": "Final value = 1, not 2", "explanation": "Lost update!"}
          ],
          "finalAnswer": "Race condition: multiple threads access shared data without synchronization",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Web Servers", "description": "Handle thousands of concurrent connections"},
        {"title": "Video Processing", "description": "Parallel rendering of frames"},
        {"title": "Data Processing", "description": "MapReduce for big data"}
      ],
      "codeExample": {
        "python": "import asyncio\n\nasync def fetch_data(url):\n    await asyncio.sleep(1)  # Simulate network\n    return f'Data from {url}'\n\nasync def main():\n    # Concurrent execution\n    results = await asyncio.gather(\n        fetch_data('url1'),\n        fetch_data('url2'),\n        fetch_data('url3')\n    )\n    print(results)",
        "javascript": "async function fetchAll(urls) {\n  const promises = urls.map(url => fetch(url));\n  const results = await Promise.all(promises);\n  return results;\n}"
      },
      "tips": [
        "Use locks/mutexes to prevent race conditions",
        "Async/await is great for I/O-bound tasks",
        "True parallelism requires multiple CPU cores"
      ]
    }
  ]
}
