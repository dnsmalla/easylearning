{
  "category": "Control Systems",
  "categoryId": "control",
  "version": "1.0.0",
  "description": "Feedback control, PID, stability, and automation",
  "icon": "slider.horizontal.3",
  "color": "#E67E22",
  "topics": [
    {
      "id": "control_intro",
      "title": "Control Systems Introduction",
      "symbol": "üéØ",
      "level": "intermediate",
      "definition": {
        "text": "Control systems automatically regulate processes to achieve desired outputs. Open-loop systems act without feedback (like a toaster timer), while closed-loop systems measure output and adjust input accordingly (like a thermostat). Closed-loop control provides accuracy and disturbance rejection.",
        "keyTerms": ["open-loop", "closed-loop", "setpoint", "feedback", "controller", "plant", "error signal"]
      },
      "keyFormulas": [
        {
          "id": "error",
          "name": "Error Signal",
          "formula": "e(t) = r(t) - y(t)",
          "latex": "e(t) = r(t) - y(t)",
          "meaning": "Error is difference between setpoint r(t) and output y(t)"
        },
        {
          "id": "closed_loop_gain",
          "name": "Closed-Loop Gain",
          "formula": "H = G / (1 + GK)",
          "latex": "H = \\frac{G}{1 + GK}",
          "meaning": "G = plant gain, K = controller gain"
        }
      ],
      "examples": [
        {
          "id": "ctrl_ex1",
          "question": "A heater has gain G=10. With controller gain K=5, what is the closed-loop gain?",
          "steps": [
            {"step": 1, "action": "Apply closed-loop formula", "result": "H = G / (1 + GK) = 10 / (1 + 10√ó5)", "explanation": "Substitute values"},
            {"step": 2, "action": "Calculate", "result": "H = 10 / 51 = 0.196", "explanation": "Closed-loop gain is much lower but more stable"}
          ],
          "finalAnswer": "H ‚âà 0.2 (feedback reduces gain but improves stability)",
          "difficulty": "medium"
        }
      ],
      "codeExample": {
        "python": "import numpy as np\nimport matplotlib.pyplot as plt\n\nclass ClosedLoopSystem:\n    def __init__(self, plant_gain, controller_gain):\n        self.G = plant_gain\n        self.K = controller_gain\n        \n    def step_response(self, setpoint, time_steps):\n        output = 0\n        outputs = []\n        for _ in range(time_steps):\n            error = setpoint - output\n            control = self.K * error\n            output += self.G * control * 0.1  # Simple integration\n            outputs.append(output)\n        return outputs\n\n# Simulate temperature control\nsystem = ClosedLoopSystem(plant_gain=0.5, controller_gain=2.0)\nresponse = system.step_response(setpoint=100, time_steps=50)\nplt.plot(response)\nplt.axhline(100, color='r', linestyle='--', label='Setpoint')\nplt.xlabel('Time Steps')\nplt.ylabel('Output')\nplt.legend()\nplt.show()",
        "arduino": "// Simple closed-loop temperature control\nconst int heaterPin = 9;\nconst int sensorPin = A0;\nfloat setpoint = 50.0;  // Target temperature\nfloat Kp = 2.0;  // Proportional gain\n\nvoid setup() {\n  pinMode(heaterPin, OUTPUT);\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  // Read temperature (simplified)\n  float temp = analogRead(sensorPin) * 0.1;  // Convert to degrees\n  \n  // Calculate error\n  float error = setpoint - temp;\n  \n  // Calculate control output\n  int output = constrain(Kp * error, 0, 255);\n  \n  analogWrite(heaterPin, output);\n  \n  Serial.print(\"Temp: \"); Serial.print(temp);\n  Serial.print(\" Error: \"); Serial.print(error);\n  Serial.print(\" Output: \"); Serial.println(output);\n  \n  delay(100);\n}"
      },
      "realWorldApplications": [
        {"title": "HVAC Systems", "description": "Thermostats maintain temperature with feedback control"},
        {"title": "Cruise Control", "description": "Cars maintain speed despite hills"},
        {"title": "Industrial Processes", "description": "Chemical plants control temperature, pressure, flow"}
      ],
      "tips": [
        "Negative feedback stabilizes; positive feedback leads to oscillation or runaway",
        "Higher loop gain reduces steady-state error but can cause instability",
        "Always test control systems for stability before deployment"
      ]
    },
    {
      "id": "pid_control",
      "title": "PID Control",
      "symbol": "üéõÔ∏è",
      "level": "intermediate",
      "definition": {
        "text": "PID (Proportional-Integral-Derivative) is the most common control algorithm. Proportional responds to current error, Integral eliminates steady-state error by accumulating past errors, and Derivative anticipates future error by responding to rate of change. Proper tuning of Kp, Ki, Kd is critical.",
        "keyTerms": ["proportional", "integral", "derivative", "Kp", "Ki", "Kd", "tuning", "overshoot", "settling time"]
      },
      "keyFormulas": [
        {
          "id": "pid_formula",
          "name": "PID Controller Output",
          "formula": "u(t) = Kp√óe(t) + Ki√ó‚à´e(t)dt + Kd√óde/dt",
          "latex": "u(t) = K_p e(t) + K_i \\int e(t)dt + K_d \\frac{de}{dt}",
          "meaning": "Control output is sum of P, I, and D terms"
        },
        {
          "id": "pid_discrete",
          "name": "Discrete PID",
          "formula": "u[n] = Kp√óe[n] + Ki√óŒ£e + Kd√ó(e[n]-e[n-1])/Œît",
          "meaning": "Digital implementation for microcontrollers"
        }
      ],
      "examples": [
        {
          "id": "pid_ex1",
          "question": "A motor position controller has error=10¬∞, error sum=50¬∞¬∑s, error change rate=-2¬∞/s. With Kp=1, Ki=0.1, Kd=0.5, what is the output?",
          "steps": [
            {"step": 1, "action": "Calculate P term", "result": "P = Kp √ó e = 1 √ó 10 = 10", "explanation": "Proportional to current error"},
            {"step": 2, "action": "Calculate I term", "result": "I = Ki √ó Œ£e = 0.1 √ó 50 = 5", "explanation": "Based on accumulated error"},
            {"step": 3, "action": "Calculate D term", "result": "D = Kd √ó de/dt = 0.5 √ó (-2) = -1", "explanation": "Anticipates based on trend"},
            {"step": 4, "action": "Sum all terms", "result": "u = 10 + 5 + (-1) = 14", "explanation": "Total control output"}
          ],
          "finalAnswer": "Control output u = 14",
          "difficulty": "medium"
        }
      ],
      "codeExample": {
        "python": "class PIDController:\n    def __init__(self, Kp, Ki, Kd, dt=0.01):\n        self.Kp = Kp\n        self.Ki = Ki\n        self.Kd = Kd\n        self.dt = dt\n        self.integral = 0\n        self.prev_error = 0\n        \n    def update(self, setpoint, measurement):\n        error = setpoint - measurement\n        \n        # Proportional\n        P = self.Kp * error\n        \n        # Integral (with anti-windup)\n        self.integral += error * self.dt\n        self.integral = max(-100, min(100, self.integral))\n        I = self.Ki * self.integral\n        \n        # Derivative\n        D = self.Kd * (error - self.prev_error) / self.dt\n        self.prev_error = error\n        \n        return P + I + D\n\n# Usage\npid = PIDController(Kp=2.0, Ki=0.5, Kd=0.1)\noutput = pid.update(setpoint=100, measurement=95)\nprint(f'Control output: {output}')",
        "arduino": "// PID Temperature Controller\nconst int heaterPin = 9;\nconst int sensorPin = A0;\n\nfloat setpoint = 60.0;  // Target temp\nfloat Kp = 2.0, Ki = 0.5, Kd = 1.0;\nfloat integral = 0, prevError = 0;\nunsigned long lastTime;\n\nvoid setup() {\n  pinMode(heaterPin, OUTPUT);\n  Serial.begin(9600);\n  lastTime = millis();\n}\n\nvoid loop() {\n  // Calculate dt\n  unsigned long now = millis();\n  float dt = (now - lastTime) / 1000.0;\n  lastTime = now;\n  \n  // Read temperature\n  float temp = analogRead(sensorPin) * 0.1;\n  float error = setpoint - temp;\n  \n  // PID calculation\n  float P = Kp * error;\n  integral += error * dt;\n  integral = constrain(integral, -50, 50);  // Anti-windup\n  float I = Ki * integral;\n  float D = Kd * (error - prevError) / dt;\n  prevError = error;\n  \n  int output = constrain(P + I + D, 0, 255);\n  analogWrite(heaterPin, output);\n  \n  Serial.print(temp); Serial.print(\",\");\n  Serial.println(output);\n  delay(100);\n}"
      },
      "realWorldApplications": [
        {"title": "Drone Flight Control", "description": "PID stabilizes attitude and position"},
        {"title": "3D Printer Hotend", "description": "Precise temperature control for extrusion"},
        {"title": "Industrial Automation", "description": "Flow, pressure, level, temperature control"}
      ],
      "tips": [
        "Start with P only, then add I to eliminate steady-state error, finally D for stability",
        "Too much I causes overshoot and oscillation",
        "Too much D amplifies noise - filter the derivative term",
        "Ziegler-Nichols method provides initial tuning values"
      ]
    },
    {
      "id": "feedback_systems",
      "title": "Feedback Systems",
      "symbol": "üîÅ",
      "level": "intermediate",
      "definition": {
        "text": "Feedback takes a portion of output and returns it to the input. Negative feedback subtracts from input, providing stability and reducing sensitivity to disturbances. Positive feedback adds to input, causing exponential growth or oscillation. Most control systems use negative feedback.",
        "keyTerms": ["negative feedback", "positive feedback", "loop gain", "stability margin", "phase margin", "gain margin"]
      },
      "keyFormulas": [
        {
          "id": "feedback_ratio",
          "name": "Feedback Ratio",
          "formula": "Œ≤ = V_feedback / V_output",
          "meaning": "Fraction of output fed back to input"
        },
        {
          "id": "loop_gain",
          "name": "Loop Gain",
          "formula": "T = AŒ≤",
          "meaning": "Open-loop gain A times feedback factor Œ≤"
        }
      ],
      "examples": [
        {
          "id": "fb_ex1",
          "question": "An amplifier has gain A=1000 and feedback Œ≤=0.1. What is the closed-loop gain?",
          "steps": [
            {"step": 1, "action": "Calculate loop gain", "result": "T = AŒ≤ = 1000 √ó 0.1 = 100", "explanation": "High loop gain means strong feedback"},
            {"step": 2, "action": "Apply closed-loop formula", "result": "Acl = A / (1 + AŒ≤) = 1000 / 101 ‚âà 9.9", "explanation": "Gain is dramatically reduced but very stable"}
          ],
          "finalAnswer": "Closed-loop gain ‚âà 10 (much more stable than open-loop 1000)",
          "difficulty": "medium"
        }
      ],
      "codeExample": {
        "python": "import numpy as np\nimport matplotlib.pyplot as plt\n\ndef simulate_feedback(A, beta, steps=100):\n    \"\"\"Simulate negative feedback response\"\"\"\n    output = 0\n    outputs = []\n    setpoint = 1.0\n    \n    for _ in range(steps):\n        error = setpoint - beta * output\n        output = A * error * 0.1  # Simple dynamics\n        outputs.append(output)\n    \n    return outputs\n\n# Compare with and without feedback\nno_fb = simulate_feedback(A=10, beta=0)\nwith_fb = simulate_feedback(A=10, beta=0.9)\n\nplt.plot(no_fb, label='No feedback')\nplt.plot(with_fb, label='With feedback (Œ≤=0.9)')\nplt.xlabel('Time Steps')\nplt.ylabel('Output')\nplt.legend()\nplt.title('Effect of Negative Feedback')\nplt.show()"
      },
      "realWorldApplications": [
        {"title": "Audio Amplifiers", "description": "Negative feedback reduces distortion"},
        {"title": "Voltage Regulators", "description": "Maintain constant output despite load changes"},
        {"title": "Biological Systems", "description": "Body temperature, blood sugar regulation"}
      ],
      "tips": [
        "Negative feedback trades gain for stability and linearity",
        "Positive feedback is used in oscillators and flip-flops",
        "Phase shift can turn negative feedback into positive at high frequencies"
      ]
    },
    {
      "id": "plc_basics",
      "title": "PLC Programming",
      "symbol": "üîß",
      "level": "intermediate",
      "definition": {
        "text": "Programmable Logic Controllers (PLCs) are industrial computers designed for automation and control. They read inputs (sensors, switches), execute a program, and control outputs (motors, valves, lights). Ladder logic is the most common PLC programming language, resembling electrical relay diagrams.",
        "keyTerms": ["ladder logic", "rung", "contacts", "coils", "timer", "counter", "I/O", "scan cycle"]
      },
      "keyFormulas": [
        {
          "id": "scan_time",
          "name": "Scan Time",
          "formula": "T_scan = T_input + T_program + T_output",
          "meaning": "Total time for one complete PLC cycle"
        }
      ],
      "examples": [
        {
          "id": "plc_ex1",
          "question": "Create ladder logic for a motor that starts with a momentary button and stops with another button",
          "steps": [
            {"step": 1, "action": "Identify inputs", "result": "Start button (I0.0), Stop button (I0.1)", "explanation": "NC stop for safety"},
            {"step": 2, "action": "Identify outputs", "result": "Motor contactor (Q0.0)", "explanation": "Controls motor"},
            {"step": 3, "action": "Add seal-in circuit", "result": "Motor contact in parallel with Start", "explanation": "Latches motor on after button release"}
          ],
          "finalAnswer": "Start-Stop circuit with seal-in: [I0.0 OR Q0.0] AND NOT I0.1 ‚Üí Q0.0",
          "difficulty": "easy"
        }
      ],
      "codeExample": {
        "python": "# Simulated PLC in Python\nclass SimplePLC:\n    def __init__(self):\n        self.inputs = {'start': False, 'stop': False, 'sensor': False}\n        self.outputs = {'motor': False, 'alarm': False}\n        self.memory = {'motor_sealed': False}\n    \n    def scan(self):\n        # Read inputs (simulated)\n        # ...\n        \n        # Execute program (ladder logic equivalent)\n        # Rung 1: Start-Stop with seal-in\n        if (self.inputs['start'] or self.memory['motor_sealed']) and not self.inputs['stop']:\n            self.outputs['motor'] = True\n            self.memory['motor_sealed'] = True\n        else:\n            self.outputs['motor'] = False\n            self.memory['motor_sealed'] = False\n        \n        # Rung 2: Alarm if sensor and motor\n        self.outputs['alarm'] = self.inputs['sensor'] and self.outputs['motor']\n        \n        # Update outputs (simulated)\n        # ...\n\nplc = SimplePLC()\nplc.inputs['start'] = True\nplc.scan()\nprint(f\"Motor: {plc.outputs['motor']}\")",
        "arduino": "// Arduino as simple PLC\n#define START_BTN 2\n#define STOP_BTN 3\n#define MOTOR_OUT 8\n#define LED_OUT 9\n\nbool motorSealed = false;\n\nvoid setup() {\n  pinMode(START_BTN, INPUT_PULLUP);\n  pinMode(STOP_BTN, INPUT_PULLUP);\n  pinMode(MOTOR_OUT, OUTPUT);\n  pinMode(LED_OUT, OUTPUT);\n}\n\nvoid loop() {\n  // Read inputs (active LOW with pullups)\n  bool startPressed = !digitalRead(START_BTN);\n  bool stopPressed = !digitalRead(STOP_BTN);\n  \n  // Ladder logic: Start-Stop with seal-in\n  if ((startPressed || motorSealed) && !stopPressed) {\n    digitalWrite(MOTOR_OUT, HIGH);\n    motorSealed = true;\n  } else {\n    digitalWrite(MOTOR_OUT, LOW);\n    motorSealed = false;\n  }\n  \n  // Status LED follows motor\n  digitalWrite(LED_OUT, motorSealed);\n  \n  delay(10);  // Scan cycle ~10ms\n}"
      },
      "realWorldApplications": [
        {"title": "Manufacturing Lines", "description": "Control conveyors, robots, and assembly machines"},
        {"title": "Water Treatment", "description": "Automated chemical dosing and filtration"},
        {"title": "Building Automation", "description": "HVAC, lighting, elevator control"}
      ],
      "tips": [
        "Always use normally-closed contacts for stop buttons (safety)",
        "Timers: TON (on-delay), TOF (off-delay), RTO (retentive)",
        "Label all I/O clearly and document your logic",
        "Test in simulation before deploying to real equipment"
      ]
    }
  ]
}

