{
  "category": "Signals & Systems",
  "categoryId": "signals",
  "version": "1.0.0",
  "description": "Signal processing, filters, and frequency analysis",
  "icon": "waveform.path",
  "color": "#1ABC9C",
  "topics": [
    {
      "id": "signal_types",
      "title": "Signal Types",
      "symbol": "ðŸ“Š",
      "level": "beginner",
      "definition": {
        "text": "Signals are time-varying quantities that carry information. They can be classified as analog (continuous) or digital (discrete), periodic or aperiodic, deterministic or random. Understanding signal types is fundamental to electronics, communications, and control systems.",
        "keyTerms": ["analog", "digital", "periodic", "aperiodic", "continuous", "discrete", "amplitude", "frequency"]
      },
      "keyFormulas": [
        {
          "id": "sine_wave",
          "name": "Sinusoidal Signal",
          "formula": "v(t) = A Ã— sin(2Ï€ft + Ï†)",
          "latex": "v(t) = A \\sin(2\\pi ft + \\phi)",
          "meaning": "A = amplitude, f = frequency (Hz), Ï† = phase (radians)"
        },
        {
          "id": "period_freq",
          "name": "Period-Frequency Relationship",
          "formula": "f = 1/T",
          "latex": "f = \\frac{1}{T}",
          "meaning": "Frequency in Hz is inverse of period in seconds"
        }
      ],
      "examples": [
        {
          "id": "sig_ex1",
          "question": "A signal has a period of 20ms. What is its frequency?",
          "steps": [
            {"step": 1, "action": "Convert period to seconds", "result": "T = 20ms = 0.02s", "explanation": "Convert milliseconds to seconds"},
            {"step": 2, "action": "Apply frequency formula", "result": "f = 1/T = 1/0.02 = 50 Hz", "explanation": "Frequency is inverse of period"}
          ],
          "finalAnswer": "f = 50 Hz",
          "difficulty": "easy"
        }
      ],
      "codeExample": {
        "python": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# Generate sine wave signal\nt = np.linspace(0, 0.1, 1000)  # 100ms\nf = 50  # 50 Hz\nA = 5   # Amplitude\n\nv = A * np.sin(2 * np.pi * f * t)\n\nplt.plot(t*1000, v)\nplt.xlabel('Time (ms)')\nplt.ylabel('Voltage (V)')\nplt.title('50 Hz Sine Wave')\nplt.grid(True)\nplt.show()",
        "javascript": "// Generate signal samples\nfunction generateSine(f, A, duration, sampleRate = 1000) {\n  const samples = [];\n  const dt = 1 / sampleRate;\n  for (let t = 0; t < duration; t += dt) {\n    samples.push(A * Math.sin(2 * Math.PI * f * t));\n  }\n  return samples;\n}\n\nconst signal = generateSine(50, 5, 0.1);\nconsole.log(`Generated ${signal.length} samples`);",
        "arduino": "// Generate PWM signal at specific frequency\nconst int signalPin = 9;\nint frequency = 50;  // Hz\nint period = 1000000 / frequency;  // microseconds\n\nvoid setup() {\n  pinMode(signalPin, OUTPUT);\n}\n\nvoid loop() {\n  digitalWrite(signalPin, HIGH);\n  delayMicroseconds(period / 2);\n  digitalWrite(signalPin, LOW);\n  delayMicroseconds(period / 2);\n}"
      },
      "realWorldApplications": [
        {"title": "Audio Signals", "description": "Music and voice are complex combinations of sine waves"},
        {"title": "Radio Broadcasting", "description": "AM and FM radio use modulated carrier signals"},
        {"title": "Medical Monitoring", "description": "ECG and EEG capture biological electrical signals"}
      ],
      "tips": [
        "Most real-world signals can be decomposed into sine waves using Fourier analysis",
        "Digital signals only have two states (0 and 1) making them noise-resistant",
        "The Nyquist theorem: sample rate must be at least 2Ã— the highest frequency"
      ]
    },
    {
      "id": "frequency_domain",
      "title": "Frequency Domain",
      "symbol": "ðŸ“ˆ",
      "level": "intermediate",
      "definition": {
        "text": "The frequency domain represents signals as combinations of sinusoids at different frequencies, rather than as variations over time. Fourier transforms convert between time and frequency domains, revealing the frequency content of signals. This is essential for filter design and signal analysis.",
        "keyTerms": ["Fourier transform", "spectrum", "harmonics", "bandwidth", "FFT", "magnitude", "phase spectrum"]
      },
      "keyFormulas": [
        {
          "id": "fourier",
          "name": "Fourier Transform",
          "formula": "X(f) = âˆ« x(t)e^(-j2Ï€ft) dt",
          "latex": "X(f) = \\int_{-\\infty}^{\\infty} x(t)e^{-j2\\pi ft} dt",
          "meaning": "Transforms time-domain signal x(t) to frequency-domain X(f)"
        },
        {
          "id": "bandwidth",
          "name": "Bandwidth",
          "formula": "BW = f_high - f_low",
          "latex": "BW = f_{high} - f_{low}",
          "meaning": "Range of frequencies contained in a signal"
        }
      ],
      "examples": [
        {
          "id": "freq_ex1",
          "question": "An audio signal contains frequencies from 20Hz to 20kHz. What is its bandwidth?",
          "steps": [
            {"step": 1, "action": "Identify frequency range", "result": "f_low = 20Hz, f_high = 20,000Hz", "explanation": "Human hearing range"},
            {"step": 2, "action": "Calculate bandwidth", "result": "BW = 20,000 - 20 = 19,980 Hz â‰ˆ 20 kHz", "explanation": "Difference between high and low frequencies"}
          ],
          "finalAnswer": "BW â‰ˆ 20 kHz",
          "difficulty": "easy"
        }
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom scipy.fft import fft, fftfreq\nimport matplotlib.pyplot as plt\n\n# Create signal with two frequencies\nfs = 1000  # Sample rate\nt = np.linspace(0, 1, fs)\nsignal = np.sin(2*np.pi*50*t) + 0.5*np.sin(2*np.pi*120*t)\n\n# Compute FFT\nN = len(signal)\nyf = fft(signal)\nxf = fftfreq(N, 1/fs)[:N//2]\n\nplt.plot(xf, 2/N * np.abs(yf[:N//2]))\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Magnitude')\nplt.title('Frequency Spectrum')\nplt.show()",
        "javascript": "// Simple DFT implementation\nfunction dft(signal) {\n  const N = signal.length;\n  const result = [];\n  for (let k = 0; k < N; k++) {\n    let real = 0, imag = 0;\n    for (let n = 0; n < N; n++) {\n      const angle = 2 * Math.PI * k * n / N;\n      real += signal[n] * Math.cos(angle);\n      imag -= signal[n] * Math.sin(angle);\n    }\n    result.push(Math.sqrt(real*real + imag*imag) / N);\n  }\n  return result;\n}"
      },
      "realWorldApplications": [
        {"title": "Audio Equalizers", "description": "Adjust frequency bands in music players"},
        {"title": "Spectrum Analyzers", "description": "Visualize signal frequency content in test equipment"},
        {"title": "Image Compression", "description": "JPEG uses DCT, a type of frequency transform"}
      ],
      "tips": [
        "FFT (Fast Fourier Transform) is much faster than DFT for large signals",
        "Frequency resolution = sample_rate / number_of_samples",
        "Window functions reduce spectral leakage in FFT analysis"
      ]
    },
    {
      "id": "sampling",
      "title": "Sampling Theory",
      "symbol": "ðŸ“",
      "level": "intermediate",
      "definition": {
        "text": "Sampling converts continuous analog signals to discrete digital signals by measuring values at regular intervals. The Nyquist-Shannon theorem states the sample rate must exceed twice the highest signal frequency to avoid aliasing (distortion). This is fundamental to all digital audio, video, and data acquisition.",
        "keyTerms": ["Nyquist rate", "aliasing", "quantization", "sample rate", "bit depth", "ADC", "reconstruction"]
      },
      "keyFormulas": [
        {
          "id": "nyquist",
          "name": "Nyquist Rate",
          "formula": "f_s â‰¥ 2 Ã— f_max",
          "latex": "f_s \\geq 2 \\cdot f_{max}",
          "meaning": "Sample rate must be at least twice the maximum signal frequency"
        },
        {
          "id": "quantization",
          "name": "Quantization Levels",
          "formula": "Levels = 2^n",
          "latex": "Levels = 2^n",
          "meaning": "n-bit ADC has 2^n discrete levels"
        },
        {
          "id": "resolution",
          "name": "ADC Resolution",
          "formula": "Resolution = V_ref / (2^n - 1)",
          "latex": "Resolution = \\frac{V_{ref}}{2^n - 1}",
          "meaning": "Voltage per step for n-bit ADC"
        }
      ],
      "examples": [
        {
          "id": "samp_ex1",
          "question": "What minimum sample rate is needed for audio with 20kHz maximum frequency?",
          "steps": [
            {"step": 1, "action": "Apply Nyquist theorem", "result": "f_s â‰¥ 2 Ã— 20,000 Hz = 40,000 Hz", "explanation": "Minimum is 40 kHz"},
            {"step": 2, "action": "Practical consideration", "result": "CD audio uses 44.1 kHz", "explanation": "Extra margin prevents aliasing"}
          ],
          "finalAnswer": "Minimum 40 kHz (CD standard: 44.1 kHz)",
          "difficulty": "easy"
        },
        {
          "id": "samp_ex2",
          "question": "A 10-bit ADC with 5V reference has what resolution?",
          "steps": [
            {"step": 1, "action": "Calculate number of levels", "result": "2^10 = 1024 levels", "explanation": "10 bits gives 1024 steps"},
            {"step": 2, "action": "Calculate voltage per step", "result": "5V / 1023 = 4.89 mV", "explanation": "Each step represents about 5mV"}
          ],
          "finalAnswer": "Resolution = 4.89 mV/step",
          "difficulty": "medium"
        }
      ],
      "codeExample": {
        "python": "import numpy as np\n\ndef simulate_sampling(signal, t, sample_rate):\n    \"\"\"Simulate ADC sampling\"\"\"\n    sample_interval = 1 / sample_rate\n    sample_times = np.arange(0, t[-1], sample_interval)\n    samples = np.interp(sample_times, t, signal)\n    return sample_times, samples\n\ndef quantize(samples, bits, v_ref):\n    \"\"\"Quantize to n-bit resolution\"\"\"\n    levels = 2**bits\n    step = v_ref / (levels - 1)\n    return np.round(samples / step) * step\n\n# Example: 8-bit quantization\nsamples = np.array([0.5, 1.2, 2.7, 3.1, 4.8])\nquantized = quantize(samples, 8, 5.0)\nprint(f'Original: {samples}')\nprint(f'Quantized: {quantized}')",
        "arduino": "// Read analog with specified precision\nconst int sensorPin = A0;\nconst float VREF = 5.0;\nconst int BITS = 10;  // Arduino Uno has 10-bit ADC\n\nvoid setup() {\n  Serial.begin(9600);\n  // For higher resolution on some boards:\n  // analogReadResolution(12);\n}\n\nvoid loop() {\n  int raw = analogRead(sensorPin);\n  float voltage = (raw * VREF) / (pow(2, BITS) - 1);\n  \n  Serial.print(\"Raw: \");\n  Serial.print(raw);\n  Serial.print(\" Voltage: \");\n  Serial.println(voltage, 3);\n  delay(100);\n}"
      },
      "realWorldApplications": [
        {"title": "Digital Audio", "description": "CD (44.1kHz/16-bit), Hi-Res Audio (96kHz/24-bit)"},
        {"title": "Data Acquisition", "description": "Oscilloscopes and sensors digitize analog signals"},
        {"title": "Digital Photography", "description": "Image sensors sample light intensity"}
      ],
      "tips": [
        "Always use anti-aliasing filters before sampling",
        "More bits = better resolution but larger data size",
        "Oversampling can improve effective resolution"
      ]
    },
    {
      "id": "passive_filters",
      "title": "Passive Filters",
      "symbol": "ðŸ”˜",
      "level": "intermediate",
      "definition": {
        "text": "Passive filters use resistors, capacitors, and inductors to pass certain frequencies while blocking others. Low-pass filters pass low frequencies, high-pass pass high frequencies, and band-pass allow a specific range. The cutoff frequency is where output power drops to half (-3dB).",
        "keyTerms": ["cutoff frequency", "low-pass", "high-pass", "band-pass", "roll-off", "time constant", "-3dB point"]
      },
      "keyFormulas": [
        {
          "id": "rc_lowpass",
          "name": "RC Low-Pass Cutoff",
          "formula": "f_c = 1 / (2Ï€RC)",
          "latex": "f_c = \\frac{1}{2\\pi RC}",
          "meaning": "Cutoff frequency for RC low-pass filter"
        },
        {
          "id": "time_constant",
          "name": "Time Constant",
          "formula": "Ï„ = RC",
          "latex": "\\tau = RC",
          "meaning": "Time to reach 63% of final value"
        },
        {
          "id": "gain_db",
          "name": "Gain in Decibels",
          "formula": "G_dB = 20 logâ‚â‚€(V_out/V_in)",
          "latex": "G_{dB} = 20 \\log_{10}(V_{out}/V_{in})",
          "meaning": "Voltage gain expressed in decibels"
        }
      ],
      "examples": [
        {
          "id": "filt_ex1",
          "question": "Design an RC low-pass filter with 1kHz cutoff using a 10kÎ© resistor",
          "steps": [
            {"step": 1, "action": "Rearrange cutoff formula for C", "result": "C = 1 / (2Ï€Rf_c)", "explanation": "Solve for capacitance"},
            {"step": 2, "action": "Substitute values", "result": "C = 1 / (2Ï€ Ã— 10,000 Ã— 1,000)", "explanation": "R = 10kÎ©, f_c = 1kHz"},
            {"step": 3, "action": "Calculate", "result": "C = 15.9 nF", "explanation": "Use 15nF or 16nF standard value"}
          ],
          "finalAnswer": "C â‰ˆ 16 nF (use 15nF standard value)",
          "difficulty": "medium"
        }
      ],
      "codeExample": {
        "python": "import numpy as np\nimport matplotlib.pyplot as plt\n\ndef rc_lowpass_response(f, R, C):\n    \"\"\"Calculate RC low-pass filter response\"\"\"\n    fc = 1 / (2 * np.pi * R * C)\n    return 1 / np.sqrt(1 + (f/fc)**2)\n\n# 1kHz cutoff filter\nR = 10000  # 10k ohm\nC = 16e-9  # 16nF\n\nf = np.logspace(1, 5, 1000)  # 10Hz to 100kHz\ngain = rc_lowpass_response(f, R, C)\ngain_db = 20 * np.log10(gain)\n\nplt.semilogx(f, gain_db)\nplt.xlabel('Frequency (Hz)')\nplt.ylabel('Gain (dB)')\nplt.title('RC Low-Pass Filter Response')\nplt.grid(True)\nplt.axhline(-3, color='r', linestyle='--', label='-3dB')\nplt.legend()\nplt.show()",
        "arduino": "// Simple RC low-pass filter simulation\n// Physical filter: connect R between input and output, C from output to GND\n\nconst int inputPin = A0;\nconst int outputPin = A1;  // After RC filter\n\nvoid setup() {\n  Serial.begin(9600);\n}\n\nvoid loop() {\n  int input = analogRead(inputPin);\n  int output = analogRead(outputPin);\n  \n  // Software low-pass filter (exponential moving average)\n  static float filtered = 0;\n  float alpha = 0.1;  // Lower = more filtering\n  filtered = alpha * input + (1 - alpha) * filtered;\n  \n  Serial.print(input);\n  Serial.print(\",\");\n  Serial.println((int)filtered);\n  delay(10);\n}"
      },
      "realWorldApplications": [
        {"title": "Audio Crossovers", "description": "Split audio to different speaker drivers"},
        {"title": "Anti-Aliasing", "description": "Remove high frequencies before ADC sampling"},
        {"title": "Noise Reduction", "description": "Low-pass filters remove high-frequency noise"}
      ],
      "tips": [
        "First-order RC filters have 20dB/decade roll-off",
        "For steeper roll-off, cascade multiple stages or use active filters",
        "Inductor-based filters handle higher power but are larger"
      ]
    }
  ]
}

