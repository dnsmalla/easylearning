{
  "category": "Error Correction",
  "categoryId": "error_correction",
  "version": "1.0.0",
  "description": "Protecting quantum information from noise and errors",
  "icon": "exclamationmark.shield",
  "color": "#EF4444",
  "topics": [
    {
      "id": "error_types",
      "title": "Types of Quantum Errors",
      "symbol": "âš ï¸",
      "level": "intermediate",
      "definition": {
        "text": "Quantum errors corrupt qubit states through three main mechanisms: bit-flip (X error, |0âŸ©â†”|1âŸ©), phase-flip (Z error, |+âŸ©â†”|-âŸ©), and their combination (Y error). The depolarizing channel randomly applies I, X, Y, or Z. Unlike classical bits, quantum errors are continuous and can be partial, but quantum error correction discretizes them into correctable Pauli errors.",
        "keyTerms": ["Bit-Flip", "Phase-Flip", "Depolarizing", "Pauli Error", "Amplitude Damping", "Dephasing", "Kraus Operators"]
      },
      "keyFormulas": [
        {
          "id": "bit_flip",
          "name": "Bit-Flip Channel",
          "formula": "Ï â†’ (1-p)Ï + pXÏX",
          "latex": "\\rho \\rightarrow (1-p)\\rho + pX\\rho X",
          "meaning": "X applied with probability p"
        },
        {
          "id": "phase_flip",
          "name": "Phase-Flip Channel",
          "formula": "Ï â†’ (1-p)Ï + pZÏZ",
          "latex": "\\rho \\rightarrow (1-p)\\rho + pZ\\rho Z",
          "meaning": "Z applied with probability p"
        },
        {
          "id": "depolarizing",
          "name": "Depolarizing Channel",
          "formula": "Ï â†’ (1-p)Ï + (p/3)(XÏX + YÏY + ZÏZ)",
          "latex": "\\rho \\rightarrow (1-p)\\rho + \\frac{p}{3}(X\\rho X + Y\\rho Y + Z\\rho Z)",
          "meaning": "Random Pauli with total probability p"
        }
      ],
      "examples": [
        {
          "id": "et_ex1",
          "question": "A qubit in |+âŸ© experiences a phase-flip error (Z). What happens?",
          "steps": [
            {"step": 1, "action": "Initial state", "result": "|+âŸ© = (|0âŸ© + |1âŸ©)/âˆš2", "explanation": "Equal superposition"},
            {"step": 2, "action": "Apply Z error", "result": "Z|+âŸ© = (Z|0âŸ© + Z|1âŸ©)/âˆš2", "explanation": "Z|0âŸ©=|0âŸ©, Z|1âŸ©=-|1âŸ©"},
            {"step": 3, "action": "Simplify", "result": "(|0âŸ© - |1âŸ©)/âˆš2 = |-âŸ©", "explanation": "Flipped to |-âŸ©"}
          ],
          "finalAnswer": "Z|+âŸ© = |-âŸ©. Phase-flip changed the superposition sign, like a bit-flip in X-basis.",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Error Models", "description": "Characterizing hardware noise"},
        {"title": "Error Mitigation", "description": "Correcting for known error types"},
        {"title": "Threshold Calculation", "description": "Determining QEC requirements"}
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom qiskit.quantum_info import Kraus, SuperOp, DensityMatrix\n\n# Bit-flip channel (probability p)\ndef bit_flip_channel(p):\n    K0 = np.sqrt(1-p) * np.eye(2)    # No error\n    K1 = np.sqrt(p) * np.array([[0,1],[1,0]])  # X error\n    return Kraus([K0, K1])\n\n# Phase-flip channel\ndef phase_flip_channel(p):\n    K0 = np.sqrt(1-p) * np.eye(2)\n    K1 = np.sqrt(p) * np.array([[1,0],[0,-1]])  # Z error\n    return Kraus([K0, K1])\n\n# Depolarizing channel\ndef depolarizing_channel(p):\n    I = np.eye(2)\n    X = np.array([[0,1],[1,0]])\n    Y = np.array([[0,-1j],[1j,0]])\n    Z = np.array([[1,0],[0,-1]])\n    K0 = np.sqrt(1-p) * I\n    K1 = np.sqrt(p/3) * X\n    K2 = np.sqrt(p/3) * Y\n    K3 = np.sqrt(p/3) * Z\n    return Kraus([K0, K1, K2, K3])\n\nprint('Quantum Error Channels')\nprint('=' * 40)\nprint('\\nApplying 10% depolarizing noise to |+âŸ©:')\nplus_state = DensityMatrix.from_label('+')\nchannel = depolarizing_channel(0.1)\nnoisy_state = plus_state.evolve(channel)\nprint(f'Original purity: {plus_state.purity():.3f}')\nprint(f'After noise:     {noisy_state.purity():.3f}')\nprint('\\nPurity decreases = information lost to environment')"
      },
      "tips": [
        "Any single-qubit error can be decomposed into Pauli errors",
        "Phase errors are invisible to computational basis measurement",
        "Hardware typically has asymmetric error rates for different types"
      ]
    },
    {
      "id": "no_cloning",
      "title": "No-Cloning Theorem",
      "symbol": "ðŸš«",
      "level": "beginner",
      "definition": {
        "text": "The No-Cloning Theorem proves that arbitrary unknown quantum states cannot be perfectly copied: there exists no unitary U such that U|ÏˆâŸ©|0âŸ© = |ÏˆâŸ©|ÏˆâŸ© for all |ÏˆâŸ©. This is fundamental to quantum mechanics and has profound implicationsâ€”it's why quantum error correction must use redundancy through entanglement rather than simple copying, and why quantum information cannot be passively protected.",
        "keyTerms": ["No-Cloning", "Copying", "Linearity", "Entanglement", "Redundancy", "QEC Strategy"]
      },
      "keyFormulas": [
        {
          "id": "cloning_attempt",
          "name": "Cloning Contradiction",
          "formula": "U(Î±|0âŸ©+Î²|1âŸ©)|0âŸ© â‰  (Î±|0âŸ©+Î²|1âŸ©)(Î±|0âŸ©+Î²|1âŸ©)",
          "latex": "U(\\alpha|0\\rangle + \\beta|1\\rangle)|0\\rangle \\neq (\\alpha|0\\rangle + \\beta|1\\rangle)^{\\otimes 2}",
          "meaning": "Linearity prevents arbitrary cloning"
        }
      ],
      "examples": [
        {
          "id": "nc_ex1",
          "question": "Prove that cloning violates linearity of quantum mechanics",
          "steps": [
            {"step": 1, "action": "Assume cloning works for basis", "result": "U|0âŸ©|0âŸ©=|00âŸ©, U|1âŸ©|0âŸ©=|11âŸ©", "explanation": "Clone basis states"},
            {"step": 2, "action": "Apply to superposition", "result": "U(|0âŸ©+|1âŸ©)|0âŸ©/âˆš2 = (|00âŸ©+|11âŸ©)/âˆš2", "explanation": "By linearity of U"},
            {"step": 3, "action": "What cloning would need", "result": "(|0âŸ©+|1âŸ©)(|0âŸ©+|1âŸ©)/2 = (|00âŸ©+|01âŸ©+|10âŸ©+|11âŸ©)/2", "explanation": "If cloning worked"},
            {"step": 4, "action": "Compare", "result": "(|00âŸ©+|11âŸ©)/âˆš2 â‰  (|00âŸ©+|01âŸ©+|10âŸ©+|11âŸ©)/2", "explanation": "Contradiction!"}
          ],
          "finalAnswer": "Cloning |0âŸ© and |1âŸ© correctly fails for |+âŸ© due to linearityâ€”no universal cloner exists",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "QKD Security", "description": "Eavesdroppers can't copy qubits"},
        {"title": "QEC Design", "description": "Must encode, not copy"},
        {"title": "Quantum Money", "description": "Unforgeable quantum tokens"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\nprint('No-Cloning Theorem Demonstration')\nprint('=' * 45)\n\n# If cloning existed, it would satisfy:\n# U|ÏˆâŸ©|0âŸ© = |ÏˆâŸ©|ÏˆâŸ© for ALL |ÏˆâŸ©\n\n# Assume it works for |0âŸ© and |1âŸ©:\n# U|0âŸ©|0âŸ© = |00âŸ©\n# U|1âŸ©|0âŸ© = |11âŸ©\n\n# For |+âŸ© = (|0âŸ© + |1âŸ©)/âˆš2, by linearity:\nprint('\\nBy linearity of U:')\nprint('  U|+âŸ©|0âŸ© = U[(|0âŸ©+|1âŸ©)/âˆš2]|0âŸ©')\nprint('         = [U|0âŸ©|0âŸ© + U|1âŸ©|0âŸ©]/âˆš2')\nprint('         = [|00âŸ© + |11âŸ©]/âˆš2  (Bell state!)')\n\nprint('\\nBut cloning would require:')\nprint('  |+âŸ©|+âŸ© = [(|0âŸ©+|1âŸ©)/âˆš2]Â²')\nprint('        = [|00âŸ© + |01âŸ© + |10âŸ© + |11âŸ©]/2')\n\nprint('\\nThese are different states!')\nprint('  Bell: (|00âŸ© + |11âŸ©)/âˆš2      - entangled')\nprint('  Clone: (|00âŸ©+|01âŸ©+|10âŸ©+|11âŸ©)/2 - product')\n\nprint('\\nâ†’ No universal cloning machine can exist.')\nprint('\\nImplications for QEC:')\nprint('  Cannot copy quantum state for redundancy')\nprint('  Must encode into entangled states instead')\nprint('  Information spread non-locally across qubits')"
      },
      "tips": [
        "No-cloning doesn't prevent copying known states (like |0âŸ©)",
        "Approximate cloning is possible with reduced fidelity",
        "Teleportation moves (not copies) quantum states"
      ]
    },
    {
      "id": "shor_code",
      "title": "Shor's 9-Qubit Code",
      "symbol": "9",
      "level": "advanced",
      "definition": {
        "text": "Shor's 9-qubit code was the first quantum error correcting code, encoding 1 logical qubit into 9 physical qubits. It corrects arbitrary single-qubit errors by combining bit-flip and phase-flip protection. The logical |0âŸ© is encoded as (|000âŸ©+|111âŸ©)âŠ—3/2âˆš2. Three blocks handle phase-flips, and each block's triple repetition handles bit-flips.",
        "keyTerms": ["9-Qubit", "Concatenation", "Bit-Flip Code", "Phase-Flip Code", "Syndrome", "Logical Qubit"]
      },
      "keyFormulas": [
        {
          "id": "shor_logical_0",
          "name": "Logical |0âŸ©",
          "formula": "|0_LâŸ© = (|+++âŸ© + |---âŸ©)/âˆš2 in X-basis blocks",
          "latex": "|0_L\\rangle = \\frac{(|000\\rangle + |111\\rangle)^{\\otimes 3}}{2\\sqrt{2}}",
          "meaning": "Three phase-flip protected blocks"
        },
        {
          "id": "shor_logical_1",
          "name": "Logical |1âŸ©",
          "formula": "|1_LâŸ© = (|+++âŸ© - |---âŸ©)/âˆš2 in X-basis blocks",
          "latex": "|1_L\\rangle = \\frac{(|000\\rangle - |111\\rangle)^{\\otimes 3}}{2\\sqrt{2}}",
          "meaning": "Phase difference encodes logical state"
        }
      ],
      "examples": [
        {
          "id": "sc_ex1",
          "question": "How does the Shor code protect against a Z error on qubit 5?",
          "steps": [
            {"step": 1, "action": "Identify affected block", "result": "Qubit 5 is in block 2 (qubits 4,5,6)", "explanation": "Middle block"},
            {"step": 2, "action": "Z error effect", "result": "|000âŸ©+|111âŸ© â†’ |000âŸ©-|111âŸ© in that block", "explanation": "Phase flip in one block"},
            {"step": 3, "action": "Syndrome detection", "result": "Measure XâŠ—X between blocks", "explanation": "Detects which block flipped"},
            {"step": 4, "action": "Correction", "result": "Apply Z to any qubit in block 2", "explanation": "Restores correct phase"}
          ],
          "finalAnswer": "Z error in block 2 is detected by inter-block parity, corrected by Z on any qubit in that block",
          "difficulty": "hard"
        }
      ],
      "realWorldApplications": [
        {"title": "Historical Importance", "description": "Proved QEC possible"},
        {"title": "Conceptual Foundation", "description": "Template for CSS codes"},
        {"title": "Educational", "description": "Clearest QEC example"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\nimport numpy as np\n\ndef shor_encode():\n    \"\"\"Encode |ÏˆâŸ© into Shor's 9-qubit code\"\"\"\n    qr = QuantumRegister(9, 'q')\n    qc = QuantumCircuit(qr)\n    \n    # Assume qubit 0 has the state to encode\n    \n    # Phase-flip encoding (spread across 3 blocks)\n    qc.cx(0, 3)\n    qc.cx(0, 6)\n    \n    # Bit-flip encoding within each block\n    qc.h([0, 3, 6])\n    qc.cx(0, 1)\n    qc.cx(0, 2)\n    qc.cx(3, 4)\n    qc.cx(3, 5)\n    qc.cx(6, 7)\n    qc.cx(6, 8)\n    \n    return qc\n\n# Create encoder\nencoder = shor_encode()\nprint('Shor 9-Qubit Code Encoder:')\nprint(encoder)\n\nprint('\\nShor Code Structure:')\nprint('  Block 1: qubits 0,1,2 - protects against bit-flips')\nprint('  Block 2: qubits 3,4,5 - protects against bit-flips')\nprint('  Block 3: qubits 6,7,8 - protects against bit-flips')\nprint('  Inter-block: protects against phase-flips')\nprint('\\nLogical states:')\nprint('  |0_LâŸ© = (|000âŸ©+|111âŸ©)âŠ—3 / 2âˆš2')\nprint('  |1_LâŸ© = (|000âŸ©-|111âŸ©)âŠ—3 / 2âˆš2')\nprint('\\nCan correct any single-qubit X, Y, or Z error!')"
      },
      "tips": [
        "Shor code is inefficient (9 physical for 1 logical) but conceptually clear",
        "It's a concatenated code: phase-flip code of bit-flip codes",
        "Modern codes like surface code are more practical"
      ]
    },
    {
      "id": "steane_code",
      "title": "Steane Code",
      "symbol": "7",
      "level": "advanced",
      "definition": {
        "text": "The Steane code is a 7-qubit code that encodes 1 logical qubit and corrects any single-qubit error. It's a CSS (Calderbank-Shor-Steane) code based on the classical Hamming [7,4,3] code. The Steane code is more efficient than Shor's (7 vs 9 qubits) and supports transversal implementation of all Clifford gates, making fault-tolerant operations easier.",
        "keyTerms": ["CSS Code", "Steane", "7-Qubit", "Hamming Code", "Transversal", "Stabilizer", "Clifford"]
      },
      "keyFormulas": [
        {
          "id": "steane_logical_0",
          "name": "Logical |0âŸ©",
          "formula": "|0_LâŸ© = Î£ |câŸ© for c âˆˆ C (even weight codewords)",
          "latex": "|0_L\\rangle = \\frac{1}{\\sqrt{8}}\\sum_{c \\in C} |c\\rangle",
          "meaning": "Superposition of Hamming codewords"
        },
        {
          "id": "steane_distance",
          "name": "Code Distance",
          "formula": "[[7, 1, 3]]",
          "latex": "[[7, 1, 3]]",
          "meaning": "7 physical qubits, 1 logical, distance 3"
        }
      ],
      "examples": [
        {
          "id": "stc_ex1",
          "question": "Why is transversal gate implementation important?",
          "steps": [
            {"step": 1, "action": "Define transversal", "result": "Apply same gate to each physical qubit", "explanation": "G_L = GâŠ—GâŠ—...âŠ—G"},
            {"step": 2, "action": "Error propagation", "result": "Single error stays single", "explanation": "No error spreading"},
            {"step": 3, "action": "Fault tolerance", "result": "Maintains correctability", "explanation": "Still correctable after gate"}
          ],
          "finalAnswer": "Transversal gates don't spread errorsâ€”a single qubit error remains a single qubit error",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Fault-Tolerant Gates", "description": "All Clifford gates transversal"},
        {"title": "Concatenation", "description": "Building larger codes from Steane"},
        {"title": "Theoretical Foundation", "description": "Model for CSS code analysis"}
      ],
      "codeExample": {
        "python": "print('Steane [[7,1,3]] Code')\nprint('=' * 45)\n\n# Steane code generators (stabilizers)\nstabilizers = [\n    'IIIXXXX',  # X-type\n    'IXXIIXX',\n    'XIXIXIX',\n    'IIIZZZZ',  # Z-type\n    'IZZIIZZ',\n    'ZIZIZIZ'\n]\n\nprint('Stabilizer generators:')\nfor i, s in enumerate(stabilizers, 1):\n    stype = 'X-type' if 'X' in s[:4] else 'Z-type'\n    print(f'  g{i}: {s}  ({stype})')\n\nprint('\\nLogical operators:')\nprint('  X_L = XXXXXXX')\nprint('  Z_L = ZZZZZZZ')\n\nprint('\\nCode properties:')\nprint('  - 7 physical qubits encode 1 logical')\nprint('  - Distance 3: corrects 1 error')\nprint('  - CSS structure: X and Z errors independent')\nprint('  - Transversal H, S, CNOT gates')\n\nprint('\\nLogical |0_LâŸ© state (sum of 8 codewords):')\ncodewords_0 = [\n    '0000000', '1010101', '0110011', '1100110',\n    '0001111', '1011010', '0111100', '1101001'\n]\nfor c in codewords_0:\n    print(f'  |{c}âŸ©')"
      },
      "tips": [
        "Steane code is the smallest CSS code with transversal Clifford",
        "X and Z errors are corrected independently (CSS property)",
        "T gate requires magic state distillation (not transversal)"
      ]
    },
    {
      "id": "surface_code",
      "title": "Surface Code",
      "symbol": "â¬›",
      "level": "advanced",
      "definition": {
        "text": "The surface code is the leading approach for scalable quantum error correction, using a 2D grid of qubits with nearest-neighbor interactions. Data qubits on vertices are checked by X and Z stabilizers on faces. It has high threshold (~1%) meaning it works with realistic error rates, and the logical error rate decreases exponentially with code distance.",
        "keyTerms": ["Surface Code", "Topological", "Threshold", "Stabilizer", "Syndrome", "Lattice Surgery", "Decoder"]
      },
      "keyFormulas": [
        {
          "id": "logical_error_rate",
          "name": "Logical Error Rate",
          "formula": "p_L âˆ (p/p_th)^((d+1)/2)",
          "latex": "p_L \\propto \\left(\\frac{p}{p_{th}}\\right)^{(d+1)/2}",
          "meaning": "Exponential suppression with distance d"
        },
        {
          "id": "qubit_overhead",
          "name": "Qubit Overhead",
          "formula": "n = (2d-1)Â² for distance d",
          "latex": "n = (2d-1)^2",
          "meaning": "Physical qubits per logical qubit"
        }
      ],
      "examples": [
        {
          "id": "surf_ex1",
          "question": "For p=0.1%, p_th=1%, how much does distance 7 vs 3 improve logical error rate?",
          "steps": [
            {"step": 1, "action": "Calculate ratio", "result": "p/p_th = 0.001/0.01 = 0.1", "explanation": "Below threshold"},
            {"step": 2, "action": "Distance 3", "result": "p_L âˆ (0.1)^2 = 0.01", "explanation": "(d+1)/2 = 2"},
            {"step": 3, "action": "Distance 7", "result": "p_L âˆ (0.1)^4 = 0.0001", "explanation": "(d+1)/2 = 4"},
            {"step": 4, "action": "Improvement", "result": "100Ã— better error rate", "explanation": "0.01/0.0001 = 100"}
          ],
          "finalAnswer": "Distance 7 has ~100Ã— lower logical error than distance 3 when p/p_th = 0.1",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Google/IBM/Microsoft", "description": "Primary QEC strategy"},
        {"title": "Quantum Memory", "description": "Long-term quantum storage"},
        {"title": "Fault-Tolerant Computation", "description": "Scalable quantum computing"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\nprint('Surface Code Overview')\nprint('=' * 45)\n\ndef surface_code_qubits(distance):\n    \"\"\"Calculate resources for surface code\"\"\"\n    data_qubits = distance ** 2\n    ancilla_qubits = (distance - 1) ** 2 + distance ** 2 - 1  # Approximate\n    total = data_qubits + ancilla_qubits\n    return data_qubits, total\n\ndef logical_error_rate(p_phys, p_threshold, distance):\n    \"\"\"Estimate logical error rate\"\"\"\n    if p_phys >= p_threshold:\n        return 1.0\n    ratio = p_phys / p_threshold\n    exponent = (distance + 1) / 2\n    return ratio ** exponent\n\nprint('Qubit overhead for different distances:')\nfor d in [3, 5, 7, 9, 11]:\n    data, total = surface_code_qubits(d)\n    print(f'  d={d}: {data} data + {total-data} ancilla = {total} total qubits')\n\nprint('\\nLogical error rate (p_phys=0.1%, p_th=1%):')\np_phys = 0.001\np_th = 0.01\nfor d in [3, 5, 7, 9, 11]:\n    p_L = logical_error_rate(p_phys, p_th, d)\n    print(f'  d={d}: p_L â‰ˆ {p_L:.2e}')\n\nprint('\\nFor fault-tolerant quantum computing:')\nprint('  Target: p_L < 10^-12 for useful computation')\nprint('  Need: d â‰ˆ 25-50 depending on p_phys')\nprint('  Qubits: ~1000-5000 physical per logical')"
      },
      "tips": [
        "Surface code has highest known threshold (~1%)",
        "2D nearest-neighbor connectivity matches hardware",
        "Lattice surgery enables logical gates between patches"
      ]
    },
    {
      "id": "fault_tolerance",
      "title": "Fault Tolerance",
      "symbol": "ðŸ›¡ï¸",
      "level": "advanced",
      "definition": {
        "text": "Fault tolerance ensures that errors during error correction don't cascade catastrophically. A fault-tolerant procedure limits error propagation so that t input errors produce at most t output errors. Key techniques include transversal gates, flag qubits, and cat state verification. With fault tolerance, arbitrarily long quantum computations become possible below the threshold error rate.",
        "keyTerms": ["Fault Tolerant", "Error Propagation", "Transversal", "Flag Qubit", "Cat State", "Code Concatenation"]
      },
      "keyFormulas": [
        {
          "id": "ft_condition",
          "name": "Fault Tolerance Condition",
          "formula": "Errors(output) â‰¤ Errors(input)",
          "latex": "\\#\\text{errors}_{out} \\leq \\#\\text{errors}_{in}",
          "meaning": "Errors don't multiply during operations"
        },
        {
          "id": "ft_threshold",
          "name": "Threshold Theorem",
          "formula": "p < p_th âŸ¹ p_L â†’ 0 as d â†’ âˆž",
          "latex": "p < p_{th} \\Rightarrow p_L \\rightarrow 0 \\text{ as } d \\rightarrow \\infty",
          "meaning": "Below threshold, errors vanish with code size"
        }
      ],
      "examples": [
        {
          "id": "ft_ex1",
          "question": "Why is a naive CNOT between two code blocks not fault-tolerant?",
          "steps": [
            {"step": 1, "action": "Consider CNOT(q1, q2)", "result": "Error on q1 propagates to q2", "explanation": "CNOT spreads X errors"},
            {"step": 2, "action": "Apply to code blocks", "result": "One error â†’ two blocks affected", "explanation": "Error in block 1 creates error in block 2"},
            {"step": 3, "action": "Problem", "result": "Single fault causes multiple errors", "explanation": "Violates FT condition"}
          ],
          "finalAnswer": "Naive CNOTs between blocks spread errorsâ€”must use transversal CNOT (qubit-by-qubit) instead",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Scalable Quantum Computing", "description": "Required for practical algorithms"},
        {"title": "Quantum Memory", "description": "Preserving states indefinitely"},
        {"title": "Algorithm Implementation", "description": "Running Shor's, chemistry simulations"}
      ],
      "codeExample": {
        "python": "print('Fault Tolerance Principles')\nprint('=' * 45)\n\nprint('\\n1. ERROR PROPAGATION')\nprint('   Bad: CNOT spreads X errors from control to target')\nprint('   Good: Transversal gates apply same gate to each qubit')\nprint('         â†’ Single error stays single error')\n\nprint('\\n2. SYNDROME EXTRACTION')\nprint('   Bad: Measure ancilla directly coupled to all data')\nprint('   Good: Use cat states or flag qubits')\nprint('         â†’ Limit damage from ancilla errors')\n\nprint('\\n3. THRESHOLD THEOREM')\nprint('   If physical error rate p < threshold p_th,')\nprint('   then we can make logical error rate arbitrarily small')\nprint('   by increasing code distance.')\nprint()\nprint('   Key thresholds:')\nprint('   - Surface code: ~1% (best known)')\nprint('   - Concatenated: ~10^-4 (more restrictive)')\nprint('   - Current hardware: ~0.1-1% (at threshold!)')\n\nprint('\\n4. UNIVERSAL FAULT-TOLERANT GATES')\nprint('   Clifford gates: Usually transversal or via lattice surgery')\nprint('   T gate: Requires magic state distillation')\nprint('   â†’ T gates are the expensive resource')\n\nprint('\\n5. RESOURCE ESTIMATES')\nprint('   Shor factoring RSA-2048:')\nprint('   - ~20 million physical qubits')\nprint('   - ~8 hours of computation')\nprint('   - Assumes surface code with ~0.1% error')"
      },
      "tips": [
        "Transversal gates are naturally fault-tolerant",
        "Not all gates can be transversalâ€”need magic states",
        "Fault tolerance has significant overhead (1000s of physical per logical)"
      ]
    },
    {
      "id": "threshold_theorem",
      "title": "Threshold Theorem",
      "symbol": "ðŸ“",
      "level": "advanced",
      "definition": {
        "text": "The Threshold Theorem proves that if the physical error rate is below a threshold p_th, then arbitrarily long quantum computations can be performed with arbitrarily low logical error rate. This is achieved by code concatenation or increasing surface code distance. The theorem provides the theoretical foundation for scalable, fault-tolerant quantum computing.",
        "keyTerms": ["Threshold", "Concatenation", "Scalability", "Overhead", "Polylogarithmic", "Accuracy"]
      },
      "keyFormulas": [
        {
          "id": "concatenation",
          "name": "Concatenation Scaling",
          "formula": "p_L^(k) = p_th Ã— (p/p_th)^(2^k)",
          "latex": "p_L^{(k)} = p_{th} \\times \\left(\\frac{p}{p_{th}}\\right)^{2^k}",
          "meaning": "k levels of concatenation, double-exponential suppression"
        },
        {
          "id": "overhead",
          "name": "Qubit Overhead",
          "formula": "n = O(poly(log(1/Îµ)))",
          "latex": "n = O(\\text{poly}(\\log(1/\\epsilon)))",
          "meaning": "Polylogarithmic overhead for error Îµ"
        }
      ],
      "examples": [
        {
          "id": "th_ex1",
          "question": "With p=0.1% and p_th=1%, how many concatenation levels for p_L < 10^-12?",
          "steps": [
            {"step": 1, "action": "Setup", "result": "p/p_th = 0.1, need p_L < 10^-12", "explanation": "Below threshold"},
            {"step": 2, "action": "Level k formula", "result": "p_L â‰ˆ (0.1)^(2^k)", "explanation": "Double-exponential"},
            {"step": 3, "action": "k=1", "result": "0.1^2 = 0.01", "explanation": "Not enough"},
            {"step": 4, "action": "k=2", "result": "0.1^4 = 10^-4", "explanation": "Still not enough"},
            {"step": 5, "action": "k=3", "result": "0.1^8 = 10^-8", "explanation": "Getting there"},
            {"step": 6, "action": "k=4", "result": "0.1^16 = 10^-16 âœ“", "explanation": "Below target"}
          ],
          "finalAnswer": "4 levels of concatenation achieves p_L â‰ˆ 10^-16 < 10^-12",
          "difficulty": "hard"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Computing Roadmaps", "description": "Guiding hardware development"},
        {"title": "Resource Estimation", "description": "Planning large-scale computation"},
        {"title": "Algorithm Feasibility", "description": "What's possible with given hardware"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\nprint('Threshold Theorem Analysis')\nprint('=' * 45)\n\ndef concatenation_error(p_phys, p_threshold, levels):\n    \"\"\"Error rate after k levels of concatenation\"\"\"\n    ratio = p_phys / p_threshold\n    exponent = 2 ** levels\n    return p_threshold * (ratio ** exponent)\n\ndef surface_code_error(p_phys, p_threshold, distance):\n    \"\"\"Logical error rate for surface code\"\"\"\n    ratio = p_phys / p_threshold\n    exponent = (distance + 1) / 2\n    return ratio ** exponent\n\np_phys = 0.001  # 0.1% physical error\np_th = 0.01     # 1% threshold\n\nprint(f'Physical error rate: {p_phys:.1%}')\nprint(f'Threshold: {p_th:.1%}')\nprint(f'Ratio p/p_th = {p_phys/p_th}')\n\nprint('\\nConcatenated codes (levels k):')\nfor k in range(1, 6):\n    p_L = concatenation_error(p_phys, p_th, k)\n    qubits = 7**k  # Steane code has 7 qubits\n    print(f'  k={k}: p_L = {p_L:.2e}, qubits = {qubits}')\n\nprint('\\nSurface code (distance d):')\nfor d in [3, 5, 7, 9, 11, 15, 21]:\n    p_L = surface_code_error(p_phys, p_th, d)\n    qubits = 2 * d**2 - 1  # Approximate\n    print(f'  d={d:2d}: p_L = {p_L:.2e}, qubits â‰ˆ {qubits}')\n\nprint('\\nKey insight:')\nprint('  Below threshold, we can achieve any target p_L')\nprint('  by investing more qubits (polynomial overhead)')"
      },
      "tips": [
        "Threshold is ~10^-4 for concatenation, ~1% for surface codes",
        "Overhead is polynomial in 1/Îµ, not exponentialâ€”scalable!",
        "We're currently at the thresholdâ€”hardware is almost good enough"
      ]
    }
  ]
}
