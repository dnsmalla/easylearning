{
  "category": "Quantum Cryptography",
  "categoryId": "cryptography",
  "version": "1.0.0",
  "description": "Quantum-safe security and quantum key distribution",
  "icon": "lock.shield",
  "color": "#64748B",
  "topics": [
    {
      "id": "quantum_threat",
      "title": "Quantum Threat to Crypto",
      "symbol": "âš ï¸",
      "level": "beginner",
      "definition": {
        "text": "Quantum computers threaten current cryptographic systems. Shor's algorithm breaks RSA, ECC, and Diffie-Hellman by efficiently factoring and computing discrete logs. Grover's algorithm halves the security of symmetric encryption (AES-256 â†’ AES-128 equivalent). This 'quantum threat' is driving migration to post-quantum cryptography before large quantum computers exist.",
        "keyTerms": ["Cryptographic Threat", "RSA", "ECC", "Factoring", "Discrete Log", "Harvest Now Decrypt Later", "Crypto Agility"]
      },
      "keyFormulas": [
        {
          "id": "shor_complexity",
          "name": "Shor's Factoring",
          "formula": "O((log N)Â³) quantum vs O(exp(N^(1/3))) classical",
          "latex": "O((\\log N)^3) \\text{ vs } O(\\exp(N^{1/3}))",
          "meaning": "Exponential speedup breaks RSA"
        },
        {
          "id": "grover_impact",
          "name": "Grover's Search",
          "formula": "O(âˆšN) vs O(N)",
          "latex": "O(\\sqrt{N}) \\text{ vs } O(N)",
          "meaning": "Halves symmetric key security"
        }
      ],
      "examples": [
        {
          "id": "qt_ex1",
          "question": "Why is 'harvest now, decrypt later' a concern today?",
          "steps": [
            {"step": 1, "action": "Current encryption", "result": "Encrypted data transmitted today", "explanation": "Using RSA/ECC"},
            {"step": 2, "action": "Adversary action", "result": "Record all encrypted traffic", "explanation": "Store for later"},
            {"step": 3, "action": "Future threat", "result": "Decrypt with quantum computer in 10-20 years", "explanation": "When quantum ready"},
            {"step": 4, "action": "Implication", "result": "Sensitive data with long secrecy needs is at risk NOW", "explanation": "Medical, government, financial"}
          ],
          "finalAnswer": "Data encrypted today can be stored and decrypted when quantum computers arriveâ€”sensitive long-term secrets are already at risk",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Government Migration", "description": "NSA requiring post-quantum by 2035"},
        {"title": "Financial Security", "description": "Banks upgrading encryption"},
        {"title": "Critical Infrastructure", "description": "Power grids, healthcare systems"}
      ],
      "codeExample": {
        "python": "print('Quantum Threat to Cryptography')\nprint('=' * 45)\n\nprint('\\nVULNERABLE SYSTEMS (broken by Shor):')\nvulnerable = [\n    ('RSA-2048', 'Key exchange, signatures', '~4000 logical qubits'),\n    ('ECC (P-256)', 'TLS, Bitcoin, SSH', '~2000 logical qubits'),\n    ('Diffie-Hellman', 'Key agreement', '~4000 logical qubits'),\n    ('DSA/ECDSA', 'Digital signatures', '~2000 logical qubits'),\n]\nfor sys, usage, req in vulnerable:\n    print(f'  {sys}:')\n    print(f'    Used for: {usage}')\n    print(f'    Requires: {req}')\n\nprint('\\nPARTIALLY AFFECTED (Grover halves security):')\naffected = [\n    ('AES-256', 'â†’ 128-bit security', 'Still secure'),\n    ('AES-128', 'â†’ 64-bit security', 'INSECURE'),\n    ('SHA-256', 'â†’ 128-bit security', 'Still secure'),\n]\nfor sys, impact, status in affected:\n    print(f'  {sys}: {impact} ({status})')\n\nprint('\\nTIMELINE CONCERNS:')\nprint('  - Large-scale quantum: ~2035-2040 (estimated)')\nprint('  - Migration time: 10-20 years for enterprise')\nprint('  - \"Harvest now, decrypt later\": threat is NOW')\nprint('\\nâ†’ Post-quantum migration must begin immediately!')"
      },
      "tips": [
        "AES-256 remains secure against quantum attacks (just double key size)",
        "Public-key cryptography (RSA, ECC) needs replacement",
        "Crypto agilityâ€”ability to swap algorithmsâ€”is crucial"
      ]
    },
    {
      "id": "bb84",
      "title": "BB84 Protocol",
      "symbol": "ðŸ”‘",
      "level": "intermediate",
      "definition": {
        "text": "BB84, invented by Bennett and Brassard in 1984, is the first quantum key distribution protocol. Alice sends qubits in random bases (Z or X) with random bit values. Bob measures in random bases. They publicly compare bases, keeping only matching-basis results. Any eavesdropper (Eve) disturbs the qubits, detectable through error rate checking.",
        "keyTerms": ["QKD", "BB84", "Basis Choice", "Key Sifting", "Error Rate", "Eavesdropping Detection", "Unconditional Security"]
      },
      "keyFormulas": [
        {
          "id": "bb84_error",
          "name": "Eavesdropping Detection",
          "formula": "QBER > 11% implies eavesdropping",
          "latex": "\\text{QBER} > 11\\%",
          "meaning": "Quantum Bit Error Rate threshold"
        },
        {
          "id": "bb84_efficiency",
          "name": "Sifting Efficiency",
          "formula": "Î· = 50% (half the bits match bases)",
          "latex": "\\eta = 50\\%",
          "meaning": "Half of transmitted bits become key"
        }
      ],
      "examples": [
        {
          "id": "bb84_ex1",
          "question": "Alice sends |+âŸ©, Bob measures in Z-basis. What happens?",
          "steps": [
            {"step": 1, "action": "Alice's state", "result": "|+âŸ© = (|0âŸ©+|1âŸ©)/âˆš2", "explanation": "Sent in X-basis"},
            {"step": 2, "action": "Bob's measurement", "result": "Z-basis: {|0âŸ©, |1âŸ©}", "explanation": "Wrong basis!"},
            {"step": 3, "action": "Outcome", "result": "50% |0âŸ©, 50% |1âŸ© randomly", "explanation": "No information"},
            {"step": 4, "action": "Sifting", "result": "This bit is discarded", "explanation": "Bases didn't match"}
          ],
          "finalAnswer": "Mismatched bases give random resultsâ€”these bits are discarded during sifting",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Commercial QKD", "description": "ID Quantique, Toshiba systems"},
        {"title": "Government Networks", "description": "Secure government communications"},
        {"title": "Financial Networks", "description": "Bank-to-bank key distribution"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\ndef simulate_bb84(n_bits, eve_present=False):\n    \"\"\"Simulate BB84 protocol\"\"\"\n    # Alice: random bits and bases\n    alice_bits = np.random.randint(0, 2, n_bits)\n    alice_bases = np.random.randint(0, 2, n_bits)  # 0=Z, 1=X\n    \n    # Eavesdropper (if present): measures in random bases\n    if eve_present:\n        eve_bases = np.random.randint(0, 2, n_bits)\n        # Eve disturbs 25% of bits on average (wrong basis 50%, wrong result 50%)\n    \n    # Bob: random measurement bases\n    bob_bases = np.random.randint(0, 2, n_bits)\n    \n    # Bob's results (affected by Eve if present)\n    bob_bits = np.copy(alice_bits)\n    if eve_present:\n        # Eve's disturbance: wrong basis â†’ 50% bit flip\n        eve_wrong_basis = eve_bases != alice_bases\n        flip_mask = eve_wrong_basis & (np.random.random(n_bits) < 0.5)\n        bob_bits[flip_mask] = 1 - bob_bits[flip_mask]\n    \n    # Bob's wrong basis also causes random result\n    bob_wrong_basis = bob_bases != alice_bases\n    flip_mask = bob_wrong_basis & (np.random.random(n_bits) < 0.5)\n    bob_bits[flip_mask] = 1 - bob_bits[flip_mask]\n    \n    # Sifting: keep only matching bases\n    matching = alice_bases == bob_bases\n    sifted_alice = alice_bits[matching]\n    sifted_bob = bob_bits[matching]\n    \n    # Calculate error rate\n    errors = np.sum(sifted_alice != sifted_bob)\n    qber = errors / len(sifted_alice) if len(sifted_alice) > 0 else 0\n    \n    return len(sifted_alice), qber\n\nprint('BB84 Protocol Simulation')\nprint('=' * 45)\n\nnp.random.seed(42)\n\nprint('\\nWithout eavesdropper:')\nfor _ in range(3):\n    key_len, qber = simulate_bb84(1000, eve_present=False)\n    print(f'  Key length: {key_len}, QBER: {qber:.1%}')\n\nprint('\\nWith eavesdropper:')\nfor _ in range(3):\n    key_len, qber = simulate_bb84(1000, eve_present=True)\n    status = 'âš ï¸ EAVESDROPPER DETECTED!' if qber > 0.11 else 'OK'\n    print(f'  Key length: {key_len}, QBER: {qber:.1%} {status}')\n\nprint('\\nBB84 Security: QBER > 11% â†’ abort key, eavesdropper detected')"
      },
      "tips": [
        "BB84 security relies on no-cloning theorem",
        "~50% of bits are kept after basis sifting",
        "Additional privacy amplification extracts secure key"
      ]
    },
    {
      "id": "e91",
      "title": "E91 Protocol",
      "symbol": "ðŸ”—",
      "level": "intermediate",
      "definition": {
        "text": "E91, proposed by Artur Ekert in 1991, uses entangled pairs for key distribution. Alice and Bob share Bell states and measure in randomly chosen bases. Security is guaranteed by Bell inequality violationâ€”any eavesdropping reduces quantum correlations below the Bell bound, detectable statistically. E91 connects QKD security to fundamental quantum mechanics.",
        "keyTerms": ["E91", "Entanglement-Based", "Bell States", "CHSH Inequality", "Device Independence", "EPR Pairs"]
      },
      "keyFormulas": [
        {
          "id": "chsh",
          "name": "CHSH Inequality",
          "formula": "|S| â‰¤ 2 classically, |S| â‰¤ 2âˆš2 quantum",
          "latex": "|S| \\leq 2 \\text{ (classical)}, |S| \\leq 2\\sqrt{2} \\text{ (quantum)}",
          "meaning": "Bell violation proves genuine entanglement"
        },
        {
          "id": "bell_test",
          "name": "Bell Test",
          "formula": "S = E(a,b) - E(a,b') + E(a',b) + E(a',b')",
          "latex": "S = E(a,b) - E(a,b') + E(a',b) + E(a',b')",
          "meaning": "Correlation function for measurement settings"
        }
      ],
      "examples": [
        {
          "id": "e91_ex1",
          "question": "Why does Bell inequality violation prove security?",
          "steps": [
            {"step": 1, "action": "Classical correlations", "result": "|S| â‰¤ 2", "explanation": "Local hidden variables limit"},
            {"step": 2, "action": "Quantum correlations", "result": "|S| = 2âˆš2 â‰ˆ 2.83 for entanglement", "explanation": "Violates classical bound"},
            {"step": 3, "action": "Eavesdropping effect", "result": "Eve's measurement reduces entanglement", "explanation": "Correlations become classical"},
            {"step": 4, "action": "Detection", "result": "S drops below 2âˆš2 toward 2", "explanation": "Measurable signature of attack"}
          ],
          "finalAnswer": "Bell violation proves untampered entanglementâ€”any eavesdropping reduces |S|, revealing the attack",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Device-Independent QKD", "description": "Security without trusting devices"},
        {"title": "Quantum Networks", "description": "Long-distance entanglement distribution"},
        {"title": "Loophole-Free Tests", "description": "Fundamental physics experiments"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\ndef simulate_e91(n_pairs, eavesdropping_strength=0):\n    \"\"\"Simulate E91 protocol with optional eavesdropping\"\"\"\n    # Measurement angles (in units of pi/8)\n    alice_settings = [0, 1, 2]  # 0, Ï€/8, Ï€/4\n    bob_settings = [1, 2, 3]    # Ï€/8, Ï€/4, 3Ï€/8\n    \n    # Generate measurement choices\n    alice_choice = np.random.choice(alice_settings, n_pairs)\n    bob_choice = np.random.choice(bob_settings, n_pairs)\n    \n    # Quantum correlation for Bell state |Î¦+âŸ©\n    # E(a,b) = -cos(a-b) for |Î¦+âŸ©\n    def quantum_correlation(a, b, noise):\n        angle = (a - b) * np.pi / 8\n        # Pure quantum: -cos(angle)\n        # With noise: reduced correlation\n        return -(1 - noise) * np.cos(angle)\n    \n    # Calculate correlations for CHSH\n    E = {}\n    for a in [0, 2]:  # Alice's CHSH settings\n        for b in [1, 3]:  # Bob's CHSH settings\n            E[(a,b)] = quantum_correlation(a, b, eavesdropping_strength)\n    \n    # CHSH value\n    S = E[(0,1)] - E[(0,3)] + E[(2,1)] + E[(2,3)]\n    \n    # Key generation (matching settings)\n    matching = alice_choice == bob_choice\n    key_bits = np.sum(matching)\n    \n    return S, key_bits\n\nprint('E91 Protocol Simulation')\nprint('=' * 45)\n\nnp.random.seed(42)\n\nprint('\\nCHSH values (|S| > 2 = quantum, â‰¤ 2 = classical/eavesdropped):')\nprint(f'  Theoretical maximum: 2âˆš2 â‰ˆ {2*np.sqrt(2):.3f}')\nprint(f'  Classical limit: 2.000')\n\nprint('\\nNo eavesdropping:')\nS, key = simulate_e91(10000, 0)\nprint(f'  S = {abs(S):.3f} > 2 âœ“ (secure)')\n\nprint('\\nWeak eavesdropping (20%):')\nS, key = simulate_e91(10000, 0.2)\nstatus = 'âœ“ secure' if abs(S) > 2 else 'âš ï¸ compromised'\nprint(f'  S = {abs(S):.3f} {status}')\n\nprint('\\nStrong eavesdropping (50%):')\nS, key = simulate_e91(10000, 0.5)\nstatus = 'âœ“ secure' if abs(S) > 2 else 'âš ï¸ compromised'\nprint(f'  S = {abs(S):.3f} {status}')"
      },
      "tips": [
        "E91 security is based on Bell test, not trusted devices",
        "Can be generalized to device-independent QKD",
        "Requires high-quality entanglement distribution"
      ]
    },
    {
      "id": "qkd_security",
      "title": "QKD Security Proofs",
      "symbol": "ðŸ“œ",
      "level": "advanced",
      "definition": {
        "text": "QKD security proofs mathematically demonstrate unconditional securityâ€”security against any attack allowed by physics, not just current technology. Key results: Lo-Chau/Shor-Preskill proved BB84 secure by reduction to entanglement distillation. Security relies on quantum mechanics itself: no-cloning, uncertainty principle, and monogamy of entanglement.",
        "keyTerms": ["Information-Theoretic Security", "Unconditional Security", "Security Proof", "Entanglement Distillation", "Privacy Amplification", "Composable Security"]
      },
      "keyFormulas": [
        {
          "id": "secure_key_rate",
          "name": "Secure Key Rate",
          "formula": "R â‰¥ 1 - H(Q) - H(E)",
          "latex": "R \\geq 1 - H(Q) - H(E)",
          "meaning": "Devetak-Winter bound for key rate"
        },
        {
          "id": "privacy_amp",
          "name": "Privacy Amplification",
          "formula": "â„“ = n(1 - H(E)) - log(1/Îµ)",
          "latex": "\\ell = n(1 - H(E)) - \\log(1/\\epsilon)",
          "meaning": "Secure key length from raw key"
        }
      ],
      "examples": [
        {
          "id": "qkd_sec_ex1",
          "question": "What makes QKD 'unconditionally' secure?",
          "steps": [
            {"step": 1, "action": "Security basis", "result": "Laws of quantum mechanics", "explanation": "Not computational assumptions"},
            {"step": 2, "action": "Classical crypto", "result": "Assumes factoring is hard", "explanation": "Could be broken by algorithm"},
            {"step": 3, "action": "QKD", "result": "No-cloning prevents undetected copying", "explanation": "Physical law, not assumption"},
            {"step": 4, "action": "Future-proof", "result": "Secure against any future computer", "explanation": "Even quantum computers"}
          ],
          "finalAnswer": "QKD security relies on physics (no-cloning), not computational hardness assumptionsâ€”secure even against quantum computers",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Long-Term Secrets", "description": "Government, military communications"},
        {"title": "Critical Infrastructure", "description": "Power grid, financial networks"},
        {"title": "Compliance", "description": "Meeting highest security standards"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\ndef binary_entropy(p):\n    \"\"\"Binary entropy function H(p)\"\"\"\n    if p == 0 or p == 1:\n        return 0\n    return -p * np.log2(p) - (1-p) * np.log2(1-p)\n\ndef secure_key_rate(qber, error_correction_efficiency=1.16):\n    \"\"\"Estimate secure key rate from QBER\"\"\"\n    # Devetak-Winter bound (simplified)\n    if qber >= 0.11:  # Above threshold\n        return 0\n    \n    # Information leaked to Eve\n    H_E = binary_entropy(qber)\n    \n    # Error correction cost\n    EC_cost = error_correction_efficiency * H_E\n    \n    # Asymptotic key rate\n    R = 1 - EC_cost - H_E\n    return max(0, R)\n\nprint('QKD Security Analysis')\nprint('=' * 45)\n\nprint('\\nSecure key rate vs QBER:')\nprint('QBER\\t| Key Rate\\t| Status')\nprint('-' * 40)\n\nfor qber in [0.01, 0.02, 0.05, 0.08, 0.10, 0.11, 0.15]:\n    R = secure_key_rate(qber)\n    if R > 0:\n        status = 'SECURE'\n    else:\n        status = 'ABORT'\n    print(f'{qber:.2f}\\t| {R:.3f}\\t\\t| {status}')\n\nprint('\\nSecurity guarantees:')\nprint('  1. Information-theoretic: no computational assumptions')\nprint('  2. Forward secrecy: past keys stay secure')\nprint('  3. Composable: safe to use with other protocols')\nprint('  4. Device-dependent: assumes trusted devices')\nprint()\nprint('  For device-independent QKD:')\nprint('  - Security from Bell violation alone')\nprint('  - No trust in measurement devices')\nprint('  - Lower key rates, harder to implement')"
      },
      "tips": [
        "Unconditional security means secure against unlimited adversary",
        "Real implementations have side-channel vulnerabilities",
        "Device-independent QKD removes device trust assumptions"
      ]
    },
    {
      "id": "post_quantum_crypto",
      "title": "Post-Quantum Cryptography",
      "symbol": "ðŸ”’",
      "level": "intermediate",
      "definition": {
        "text": "Post-quantum cryptography (PQC) refers to classical cryptographic algorithms believed secure against quantum computers. NIST standardized CRYSTALS-Kyber (key encapsulation) and CRYSTALS-Dilithium, FALCON, SPHINCS+ (signatures) in 2024. These are based on mathematical problems like lattice problems and hash functions that quantum algorithms don't efficiently solve.",
        "keyTerms": ["Post-Quantum", "NIST", "Lattice", "CRYSTALS-Kyber", "CRYSTALS-Dilithium", "Learning With Errors", "Hash-Based Signatures"]
      },
      "keyFormulas": [
        {
          "id": "lwe",
          "name": "Learning With Errors",
          "formula": "b = As + e (mod q)",
          "latex": "\\mathbf{b} = A\\mathbf{s} + \\mathbf{e} \\pmod{q}",
          "meaning": "Hard problem underlying lattice crypto"
        },
        {
          "id": "svp",
          "name": "Shortest Vector Problem",
          "formula": "Find v âˆˆ L, ||v|| minimal",
          "latex": "\\text{Find } \\mathbf{v} \\in \\mathcal{L}, ||\\mathbf{v}|| \\text{ minimal}",
          "meaning": "Hard even for quantum computers"
        }
      ],
      "examples": [
        {
          "id": "pqc_ex1",
          "question": "Why are lattice problems believed quantum-resistant?",
          "steps": [
            {"step": 1, "action": "Shor's algorithm", "result": "Uses period-finding, QFT", "explanation": "Works for factoring, DLog"},
            {"step": 2, "action": "Lattice problems", "result": "No periodic structure", "explanation": "QFT doesn't help"},
            {"step": 3, "action": "Best quantum attack", "result": "Only ~square root speedup", "explanation": "Similar to Grover"},
            {"step": 4, "action": "Security", "result": "Increase key size by 2x", "explanation": "Compensates for Grover"}
          ],
          "finalAnswer": "Lattice problems lack the algebraic structure Shor exploitsâ€”no exponential quantum speedup known",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "NIST Standards", "description": "Kyber, Dilithium now standardized"},
        {"title": "TLS Migration", "description": "Chrome, Firefox testing PQC"},
        {"title": "Hybrid Schemes", "description": "PQC + classical for defense-in-depth"}
      ],
      "codeExample": {
        "python": "print('Post-Quantum Cryptography Overview')\nprint('=' * 45)\n\nprint('\\nNIST PQC Standards (2024):')\nprint('\\nKEY ENCAPSULATION (replacing RSA/ECDH):')\npqc_kem = [\n    ('CRYSTALS-Kyber (ML-KEM)', 'Lattice (LWE)', '~1.5 KB public key'),\n]\nfor name, basis, size in pqc_kem:\n    print(f'  {name}')\n    print(f'    Basis: {basis}')\n    print(f'    Size: {size}')\n\nprint('\\nDIGITAL SIGNATURES (replacing ECDSA/RSA-sig):')\npqc_sig = [\n    ('CRYSTALS-Dilithium (ML-DSA)', 'Lattice (LWE)', '~2.4 KB signature'),\n    ('FALCON', 'Lattice (NTRU)', '~0.7 KB signature'),\n    ('SPHINCS+', 'Hash-based', '~7.8 KB signature'),\n]\nfor name, basis, size in pqc_sig:\n    print(f'  {name}')\n    print(f'    Basis: {basis}')\n    print(f'    Size: {size}')\n\nprint('\\nKey Size Comparison:')\nprint('  Algorithm\\t\\t| Public Key  | Signature/Ciphertext')\nprint('  ' + '-' * 55)\nprint('  RSA-2048\\t\\t| 256 B       | 256 B')\nprint('  ECDSA (P-256)\\t\\t| 64 B        | 64 B')\nprint('  Kyber-768\\t\\t| 1,184 B     | 1,088 B')\nprint('  Dilithium-2\\t\\t| 1,312 B     | 2,420 B')\nprint('\\nâ†’ PQC has larger sizes but is quantum-resistant')\n\nprint('\\nMigration Timeline:')\nprint('  2024: NIST standards finalized')\nprint('  2024-2030: Industry adoption')\nprint('  2030-2035: Regulatory requirements')\nprint('  2035+: Quantum computers may break RSA')"
      },
      "tips": [
        "PQC is classical cryptoâ€”runs on regular computers",
        "Larger key/signature sizes than RSA/ECC",
        "Use hybrid (classical + PQC) during transition"
      ]
    },
    {
      "id": "lattice_crypto",
      "title": "Lattice-Based Crypto",
      "symbol": "â¬¡",
      "level": "advanced",
      "definition": {
        "text": "Lattice-based cryptography builds security on the hardness of lattice problems like Learning With Errors (LWE) and Shortest Vector Problem (SVP). A lattice is a regular grid of points in n-dimensional space. Finding short vectors or solving noisy linear equations is hard classically and quantumly. CRYSTALS-Kyber and Dilithium use module-LWE for efficiency.",
        "keyTerms": ["Lattice", "LWE", "Ring-LWE", "Module-LWE", "SVP", "CVP", "NTRU", "Gaussian Noise"]
      },
      "keyFormulas": [
        {
          "id": "lwe_problem",
          "name": "LWE Problem",
          "formula": "Given (A, b = As + e), find s",
          "latex": "\\text{Given } (A, \\mathbf{b} = A\\mathbf{s} + \\mathbf{e}), \\text{ find } \\mathbf{s}",
          "meaning": "Noisy linear equations hard to solve"
        },
        {
          "id": "ring_lwe",
          "name": "Ring-LWE",
          "formula": "b = aÂ·s + e in R_q = Z_q[x]/(x^n+1)",
          "latex": "b = a \\cdot s + e \\text{ in } R_q",
          "meaning": "Structured variant for efficiency"
        }
      ],
      "examples": [
        {
          "id": "lc_ex1",
          "question": "How does the error 'e' in LWE provide security?",
          "steps": [
            {"step": 1, "action": "Without error", "result": "b = As is easy to invert", "explanation": "Gaussian elimination"},
            {"step": 2, "action": "With small error", "result": "b â‰ˆ As, but not exact", "explanation": "Can't use linear algebra"},
            {"step": 3, "action": "Finding s", "result": "Must search exponential space", "explanation": "No efficient algorithm known"},
            {"step": 4, "action": "Key insight", "result": "Error hides the linear structure", "explanation": "Noise is the security"}
          ],
          "finalAnswer": "The small error 'e' prevents linear algebra attacksâ€”finding s requires searching an exponential space",
          "difficulty": "hard"
        }
      ],
      "realWorldApplications": [
        {"title": "CRYSTALS-Kyber", "description": "NIST standard key encapsulation"},
        {"title": "CRYSTALS-Dilithium", "description": "NIST standard signatures"},
        {"title": "Fully Homomorphic Encryption", "description": "Computing on encrypted data"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\ndef lwe_example(n=4, q=97, error_bound=3):\n    \"\"\"Simple LWE demonstration\"\"\"\n    # Secret key\n    s = np.random.randint(0, q, n)\n    \n    # Public matrix A (random)\n    A = np.random.randint(0, q, (n, n))\n    \n    # Error vector (small)\n    e = np.random.randint(-error_bound, error_bound + 1, n)\n    \n    # Public value b = As + e mod q\n    b = (A @ s + e) % q\n    \n    return A, b, s, e\n\nprint('Lattice-Based Cryptography (LWE)')\nprint('=' * 45)\n\nnp.random.seed(42)\nA, b, s, e = lwe_example()\n\nprint('\\nLWE Problem Setup:')\nprint(f'  Secret s = {s}')\nprint(f'  Error e = {e}')\nprint(f'  Public A:\\n{A}')\nprint(f'  Public b = As + e mod q = {b}')\n\nprint('\\nThe Problem:')\nprint('  Given (A, b), find s')\nprint('  Without e: easy (Gaussian elimination)')\nprint('  With e: believed hard (even for quantum!)')\n\nprint('\\nKyber Key Exchange (simplified):')\nprint('  1. Alice generates (A, s, e) â†’ public key (A, b=As+e)')\nprint('  2. Bob: picks random r, computes (u=Ar+e\\', v=br+e\\\")')\nprint('  3. Bob encodes message in v')\nprint('  4. Alice decrypts using s: v - su â‰ˆ message')\nprint('     (errors cancel out with careful parameters)')\n\nprint('\\nSecurity: No known quantum algorithm solves LWE efficiently')"
      },
      "tips": [
        "LWE security reduces to worst-case lattice problems",
        "Ring/Module variants are faster, used in standards",
        "Error distribution and parameters are crucial for security"
      ]
    }
  ]
}
