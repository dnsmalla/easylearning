{
  "category": "Quantum Circuits",
  "categoryId": "circuits",
  "version": "1.0.0",
  "description": "Building and running quantum programs using quantum circuits",
  "icon": "point.3.connected.trianglepath.dotted",
  "color": "#14B8A6",
  "topics": [
    {
      "id": "circuit_model",
      "title": "Circuit Model",
      "symbol": "üìã",
      "level": "beginner",
      "definition": {
        "text": "The quantum circuit model is the dominant paradigm for quantum computation, where quantum programs are sequences of gates applied to qubits, visualized as wires. Information flows left-to-right through gates (boxes), with measurement at the end extracting classical results. This model is equivalent in power to other quantum computing models like adiabatic or measurement-based.",
        "keyTerms": ["Quantum Circuit", "Gate", "Wire", "Qubit Register", "Classical Register", "Measurement", "Circuit Diagram"]
      },
      "keyFormulas": [
        {
          "id": "circuit_unitary",
          "name": "Circuit as Unitary",
          "formula": "U = G‚Çô √ó G‚Çô‚Çã‚ÇÅ √ó ... √ó G‚ÇÇ √ó G‚ÇÅ",
          "latex": "U = G_n \\cdot G_{n-1} \\cdots G_2 \\cdot G_1",
          "meaning": "Gates multiply right-to-left (last gate first)"
        },
        {
          "id": "final_state",
          "name": "Final State",
          "formula": "|œà_final‚ü© = U|œà_initial‚ü©",
          "latex": "|\\psi_{final}\\rangle = U|\\psi_{initial}\\rangle",
          "meaning": "Apply circuit unitary to initial state"
        }
      ],
      "examples": [
        {
          "id": "cm_ex1",
          "question": "In a circuit with H then X on one qubit, what is the resulting state starting from |0‚ü©?",
          "steps": [
            {"step": 1, "action": "Apply H to |0‚ü©", "result": "|+‚ü© = (|0‚ü©+|1‚ü©)/‚àö2", "explanation": "First gate: Hadamard"},
            {"step": 2, "action": "Apply X to |+‚ü©", "result": "X|+‚ü© = (X|0‚ü©+X|1‚ü©)/‚àö2", "explanation": "Second gate: X"},
            {"step": 3, "action": "Simplify", "result": "(|1‚ü©+|0‚ü©)/‚àö2 = |+‚ü©", "explanation": "X swaps |0‚ü© and |1‚ü©"}
          ],
          "finalAnswer": "H then X on |0‚ü© gives |+‚ü© (same as just H, since X|+‚ü©=|+‚ü©)",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Programming", "description": "Qiskit, Cirq, Q# all use circuit model"},
        {"title": "Algorithm Design", "description": "Algorithms expressed as circuit diagrams"},
        {"title": "Hardware Compilation", "description": "Circuits compiled to physical operations"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\n# Create a quantum circuit with 2 qubits and 2 classical bits\nqc = QuantumCircuit(2, 2)\n\n# Add gates (left to right in time)\nqc.h(0)        # Hadamard on qubit 0\nqc.cx(0, 1)    # CNOT from qubit 0 to 1\nqc.measure([0, 1], [0, 1])  # Measure both qubits\n\n# Display the circuit\nprint('Quantum Circuit:')\nprint(qc)\n\n# Simulate\nsim = AerSimulator()\nresult = sim.run(transpile(qc, sim), shots=1000).result()\nprint(f'\\nResults: {result.get_counts()}')"
      },
      "tips": [
        "Time flows left to right in circuit diagrams",
        "Gates are applied in reading order (left to right)",
        "Each horizontal line represents one qubit's evolution"
      ]
    },
    {
      "id": "circuit_notation",
      "title": "Circuit Notation",
      "symbol": "‚Äî[H]‚Äî",
      "level": "beginner",
      "definition": {
        "text": "Circuit notation uses visual symbols to represent quantum operations. Single-qubit gates appear as labeled boxes (H, X, T). Two-qubit gates use control dots (‚Ä¢) connected to targets (‚äï for CNOT). Measurement uses a meter symbol. Double lines represent classical wires. This notation is universal across quantum computing platforms.",
        "keyTerms": ["Wire", "Gate Box", "Control Dot", "Target", "Measurement Symbol", "Classical Wire", "Barrier"]
      },
      "keyFormulas": [
        {
          "id": "notation_symbols",
          "name": "Common Symbols",
          "formula": "‚Ä¢ = control, ‚äï = CNOT target, ‚ñ¢ = measurement",
          "latex": "\\bullet = \\text{control}, \\oplus = \\text{CNOT target}",
          "meaning": "Standard circuit notation elements"
        }
      ],
      "examples": [
        {
          "id": "cn_ex1",
          "question": "Draw a circuit that creates a Bell state |Œ¶‚Å∫‚ü©",
          "steps": [
            {"step": 1, "action": "Start with two |0‚ü© qubits", "result": "Two horizontal wires", "explanation": "q0 and q1"},
            {"step": 2, "action": "Add Hadamard on q0", "result": "‚Äî[H]‚Äî on top wire", "explanation": "Creates superposition"},
            {"step": 3, "action": "Add CNOT from q0 to q1", "result": "‚Ä¢ on top, ‚äï on bottom, connected", "explanation": "Entangles qubits"}
          ],
          "finalAnswer": "q0: ‚Äî[H]‚Äî‚Ä¢‚Äî | q1: ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚äï‚Äî creates Bell state",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Documentation", "description": "Standard way to communicate algorithms"},
        {"title": "Publications", "description": "Circuit diagrams in research papers"},
        {"title": "Education", "description": "Teaching quantum algorithms visually"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit\n\n# Create various circuit elements for notation demo\nqc = QuantumCircuit(3, 3)\n\n# Single qubit gates (box notation)\nqc.h(0)    # Hadamard: [H]\nqc.x(1)    # Pauli-X: [X]\nqc.t(2)    # T gate: [T]\n\n# Add barrier (vertical dashed line)\nqc.barrier()\n\n# Two-qubit gates\nqc.cx(0, 1)   # CNOT: ‚Ä¢ connected to ‚äï\nqc.cz(1, 2)   # CZ: ‚Ä¢ connected to ‚Ä¢\n\nqc.barrier()\n\n# Measurement (meter symbol)\nqc.measure([0, 1, 2], [0, 1, 2])\n\nprint('Circuit with various notation elements:')\nprint(qc)\nprint('\\nNotation guide:')\nprint('  [H], [X], [T] = single-qubit gates')\nprint('  ‚Ä¢ with line = control qubit')\nprint('  ‚äï = CNOT target')\nprint('  ‚ïë = barrier (visual separator)')\nprint('  M = measurement')"
      },
      "tips": [
        "Control dots (‚Ä¢) always connect vertically to targets",
        "Barriers don't affect computation‚Äîthey're visual separators",
        "Double lines after measurement indicate classical information"
      ]
    },
    {
      "id": "circuit_depth",
      "title": "Circuit Depth",
      "symbol": "üìè",
      "level": "intermediate",
      "definition": {
        "text": "Circuit depth is the number of 'time steps' or layers of gates that cannot be parallelized‚Äîthe critical path length. Gates on different qubits can run simultaneously (same depth layer), but sequential gates on the same qubit add depth. Lower depth is better for NISQ devices since decoherence accumulates over time.",
        "keyTerms": ["Depth", "Layer", "Parallel Gates", "Critical Path", "NISQ", "Decoherence", "T-depth"]
      },
      "keyFormulas": [
        {
          "id": "depth_formula",
          "name": "Circuit Depth",
          "formula": "Depth = max(critical path length over all qubits)",
          "latex": "\\text{Depth} = \\max_q (\\text{gates on qubit } q)",
          "meaning": "Longest chain of non-parallelizable gates"
        },
        {
          "id": "error_accumulation",
          "name": "Error Accumulation",
          "formula": "P(error) ‚âà 1 - (1-p)^d ‚âà p√ód for small p",
          "latex": "P_{error} \\approx p \\times d",
          "meaning": "p = gate error rate, d = depth"
        }
      ],
      "examples": [
        {
          "id": "cd_ex1",
          "question": "What's the depth of a circuit with H on q0, then CNOT(0,1), then X on q0 and Z on q1 simultaneously?",
          "steps": [
            {"step": 1, "action": "Layer 1: H on q0", "result": "Depth 1 (q1 idle)", "explanation": "First operation"},
            {"step": 2, "action": "Layer 2: CNOT(0,1)", "result": "Depth 2 (both qubits used)", "explanation": "Second operation"},
            {"step": 3, "action": "Layer 3: X on q0, Z on q1", "result": "Depth 3 (parallel)", "explanation": "Same layer since independent"}
          ],
          "finalAnswer": "Circuit depth = 3 (H, CNOT, then parallel X/Z)",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "NISQ Optimization", "description": "Minimizing depth for noisy hardware"},
        {"title": "Circuit Compilation", "description": "Optimizing for depth during transpilation"},
        {"title": "Algorithm Complexity", "description": "Depth as a computational resource measure"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\n# Create a circuit and analyze depth\nqc = QuantumCircuit(3)\n\n# Layer 1: Parallel H gates (depth 1)\nqc.h([0, 1, 2])\n\n# Layer 2-3: CNOTs (sequential, add depth)\nqc.cx(0, 1)  # Depth 2\nqc.cx(1, 2)  # Depth 3\n\n# Layer 4: Parallel rotations (depth 4)\nqc.rz(0.5, 0)\nqc.rz(0.5, 1)\nqc.rz(0.5, 2)\n\nprint(f'Circuit:')\nprint(qc)\nprint(f'\\nCircuit depth: {qc.depth()}')\nprint(f'Gate count: {qc.count_ops()}')\n\n# Transpile and see depth with native gates\nsim = AerSimulator()\nqc_transpiled = transpile(qc, sim, optimization_level=3)\nprint(f'\\nTranspiled depth: {qc_transpiled.depth()}')"
      },
      "tips": [
        "Depth matters more than gate count for NISQ devices",
        "Parallelizable gates don't add depth‚Äîonly sequential ones do",
        "Target depth < T1/T_gate for reasonable fidelity"
      ]
    },
    {
      "id": "quantum_registers",
      "title": "Quantum Registers",
      "symbol": "üìù",
      "level": "beginner",
      "definition": {
        "text": "Quantum registers are named collections of qubits that can be addressed together. They help organize complex circuits by grouping related qubits (e.g., 'data' vs 'ancilla'). Classical registers store measurement results. Registers are essential for structured quantum programs, especially in error correction and arithmetic.",
        "keyTerms": ["QuantumRegister", "ClassicalRegister", "Named Qubits", "Ancilla", "Data Qubit", "Organization"]
      },
      "keyFormulas": [
        {
          "id": "register_size",
          "name": "Register State Space",
          "formula": "dim = 2^n for n-qubit register",
          "latex": "\\dim(\\mathcal{H}) = 2^n",
          "meaning": "Exponential state space growth"
        }
      ],
      "examples": [
        {
          "id": "qr_ex1",
          "question": "Design registers for a 3-qubit Grover search with 1 ancilla for the oracle",
          "steps": [
            {"step": 1, "action": "Create search register", "result": "QuantumRegister(3, 'search')", "explanation": "Main search space"},
            {"step": 2, "action": "Create ancilla register", "result": "QuantumRegister(1, 'ancilla')", "explanation": "For phase kickback"},
            {"step": 3, "action": "Create classical register", "result": "ClassicalRegister(3, 'result')", "explanation": "Store measurements"}
          ],
          "finalAnswer": "3 qubits in 'search', 1 in 'ancilla', 3 classical bits for results",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Error Correction", "description": "Separate data and syndrome qubits"},
        {"title": "Quantum Arithmetic", "description": "Organize input, output, and carry registers"},
        {"title": "Modular Circuits", "description": "Reusable circuit components with named registers"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n\n# Create named registers\ndata = QuantumRegister(2, 'data')\nancilla = QuantumRegister(1, 'ancilla')\nresult = ClassicalRegister(2, 'result')\n\n# Create circuit with registers\nqc = QuantumCircuit(data, ancilla, result)\n\n# Access qubits by register\nqc.h(data)           # H on all data qubits\nqc.x(ancilla[0])     # X on ancilla\nqc.h(ancilla[0])     # H on ancilla (phase kickback setup)\n\n# CNOT using register indices\nqc.cx(data[0], ancilla[0])\nqc.cx(data[1], ancilla[0])\n\n# Measure data register\nqc.measure(data, result)\n\nprint('Circuit with named registers:')\nprint(qc)\nprint(f'\\nRegisters:')\nprint(f'  data: {data}')\nprint(f'  ancilla: {ancilla}')\nprint(f'  result (classical): {result}')"
      },
      "tips": [
        "Use descriptive register names for clarity",
        "Ancilla qubits are typically initialized separately",
        "Classical registers can have different sizes than quantum"
      ]
    },
    {
      "id": "oracle_circuits",
      "title": "Oracle Circuits",
      "symbol": "üîÆ",
      "level": "intermediate",
      "definition": {
        "text": "An oracle is a black-box circuit that encodes problem information, typically marking solutions with a phase flip. In Grover's algorithm, the oracle flips the sign of |x‚ü© if x is a solution: O|x‚ü© = (-1)^f(x)|x‚ü©. Oracles are also used in Deutsch-Jozsa, Simon's, and other query-based algorithms. The query complexity measures algorithm efficiency.",
        "keyTerms": ["Oracle", "Black Box", "Phase Oracle", "Query Complexity", "Marking States", "Function Encoding"]
      },
      "keyFormulas": [
        {
          "id": "phase_oracle",
          "name": "Phase Oracle",
          "formula": "O‚Çì|x‚ü© = (-1)^f(x)|x‚ü©",
          "latex": "O_x|x\\rangle = (-1)^{f(x)}|x\\rangle",
          "meaning": "Phase flip for solutions where f(x)=1"
        },
        {
          "id": "bit_oracle",
          "name": "Bit-Flip Oracle",
          "formula": "O|x,y‚ü© = |x, y‚äïf(x)‚ü©",
          "latex": "O|x,y\\rangle = |x, y \\oplus f(x)\\rangle",
          "meaning": "XOR result into ancilla qubit"
        }
      ],
      "examples": [
        {
          "id": "oc_ex1",
          "question": "Build a phase oracle that marks |11‚ü© in a 2-qubit system",
          "steps": [
            {"step": 1, "action": "Identify marked state", "result": "|11‚ü© has both qubits = 1", "explanation": "Condition to check"},
            {"step": 2, "action": "Use controlled-Z", "result": "CZ flips phase when both |1‚ü©", "explanation": "CZ|11‚ü© = -|11‚ü©"},
            {"step": 3, "action": "Alternative: CCNOT + H", "result": "Use ancilla in |-‚ü© for phase kickback", "explanation": "Standard construction"}
          ],
          "finalAnswer": "CZ gate directly marks |11‚ü©: CZ|11‚ü© = -|11‚ü©, all others unchanged",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Grover's Search", "description": "Oracle marks solution states"},
        {"title": "Quantum SAT Solvers", "description": "Encode satisfiability conditions"},
        {"title": "Database Search", "description": "Mark matching entries"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\ndef phase_oracle_mark_state(n_qubits, marked_state):\n    \"\"\"Create oracle that marks |marked_state‚ü© with phase flip\"\"\"\n    qc = QuantumCircuit(n_qubits)\n    \n    # Flip qubits where marked_state has 0\n    binary = format(marked_state, f'0{n_qubits}b')\n    for i, bit in enumerate(reversed(binary)):\n        if bit == '0':\n            qc.x(i)\n    \n    # Multi-controlled Z (marks when all qubits are |1‚ü©)\n    if n_qubits == 2:\n        qc.cz(0, 1)\n    else:\n        # Use ancilla-free multi-controlled Z\n        qc.h(n_qubits - 1)\n        qc.mcx(list(range(n_qubits - 1)), n_qubits - 1)\n        qc.h(n_qubits - 1)\n    \n    # Flip back\n    for i, bit in enumerate(reversed(binary)):\n        if bit == '0':\n            qc.x(i)\n    \n    return qc\n\n# Example: Oracle marking |10‚ü© in 2-qubit system\noracle = phase_oracle_mark_state(2, 2)  # 2 = |10‚ü©\nprint('Oracle for marking |10‚ü©:')\nprint(oracle)\n\n# Verify with simulation\nqc = QuantumCircuit(2)\nqc.h([0, 1])  # Superposition\nqc = qc.compose(oracle)\nqc.h([0, 1])  # Check amplitudes\n\nfrom qiskit.quantum_info import Statevector\nsv = Statevector.from_instruction(qc)\nprint(f'\\nState after oracle + H: {sv}')"
      },
      "tips": [
        "Phase oracles are preferred over bit-flip oracles (no ancilla needed)",
        "Phase kickback: use ancilla in |-‚ü© to convert bit-flip to phase oracle",
        "Oracle complexity is a key metric for quantum algorithm efficiency"
      ]
    },
    {
      "id": "amplitude_amplification",
      "title": "Amplitude Amplification",
      "symbol": "üìà",
      "level": "intermediate",
      "definition": {
        "text": "Amplitude amplification is a generalization of Grover's search that boosts the probability of desired outcomes. Starting from any state with non-zero overlap with solutions, repeated application of (inversion about mean) √ó (oracle) rotates the state toward solutions. It's the core technique behind quantum speedups in search and optimization.",
        "keyTerms": ["Amplitude", "Amplification", "Grover Operator", "Diffusion", "Inversion About Mean", "Rotation"]
      },
      "keyFormulas": [
        {
          "id": "grover_iterate",
          "name": "Grover Iteration",
          "formula": "G = D √ó O where D = 2|s‚ü©‚ü®s| - I",
          "latex": "G = D \\cdot O, \\quad D = 2|s\\rangle\\langle s| - I",
          "meaning": "Diffusion operator D, Oracle O"
        },
        {
          "id": "optimal_angle",
          "name": "Rotation per Iteration",
          "formula": "ŒîŒ∏ = 2 arcsin(‚àö(M/N))",
          "latex": "\\Delta\\theta = 2\\arcsin\\sqrt{M/N}",
          "meaning": "M solutions among N items"
        }
      ],
      "examples": [
        {
          "id": "aa_ex1",
          "question": "Starting with 25% overlap with solutions, how many iterations to reach ~100%?",
          "steps": [
            {"step": 1, "action": "Initial amplitude", "result": "sin(Œ∏‚ÇÄ) = ‚àö0.25 = 0.5, Œ∏‚ÇÄ = œÄ/6", "explanation": "Initial angle"},
            {"step": 2, "action": "Target angle", "result": "Œ∏_target = œÄ/2 for 100%", "explanation": "Maximum probability"},
            {"step": 3, "action": "Rotation per step", "result": "ŒîŒ∏ = 2Œ∏‚ÇÄ = œÄ/3 per iteration", "explanation": "For this case"},
            {"step": 4, "action": "Calculate iterations", "result": "(œÄ/2 - œÄ/6) / (œÄ/3) = 1", "explanation": "One iteration!"}
          ],
          "finalAnswer": "Just 1 iteration brings 25% to ~100% (actually reaches exactly 100% in this case)",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Search", "description": "Grover's algorithm core technique"},
        {"title": "Quantum Counting", "description": "Estimate number of solutions"},
        {"title": "Optimization", "description": "Boost good solutions in QAOA"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\ndef diffusion_operator(n_qubits):\n    \"\"\"Inversion about mean operator\"\"\"\n    qc = QuantumCircuit(n_qubits)\n    qc.h(range(n_qubits))\n    qc.x(range(n_qubits))\n    \n    # Multi-controlled Z\n    qc.h(n_qubits - 1)\n    qc.mcx(list(range(n_qubits - 1)), n_qubits - 1)\n    qc.h(n_qubits - 1)\n    \n    qc.x(range(n_qubits))\n    qc.h(range(n_qubits))\n    return qc\n\n# Demonstrate amplitude amplification\nn = 3  # 8 states\nmarked = 5  # Target |101‚ü©\n\nqc = QuantumCircuit(n, n)\nqc.h(range(n))  # Uniform superposition\n\n# Optimal iterations\niterations = int(np.round(np.pi/4 * np.sqrt(2**n)))\nprint(f'Optimal iterations for {2**n} items: {iterations}')\n\n# Show probability growth\nfor k in range(iterations + 1):\n    test_qc = qc.copy()\n    test_qc.measure_all()\n    \n    from qiskit.quantum_info import Statevector\n    sv = Statevector.from_instruction(qc)\n    prob = abs(sv[marked])**2\n    print(f'After {k} iterations: P(|{marked:03b}‚ü©) = {prob:.3f}')\n    \n    if k < iterations:\n        # Apply oracle (phase flip on marked)\n        binary = format(marked, f'0{n}b')\n        for i, bit in enumerate(reversed(binary)):\n            if bit == '0': qc.x(i)\n        qc.h(n-1)\n        qc.mcx(list(range(n-1)), n-1)\n        qc.h(n-1)\n        for i, bit in enumerate(reversed(binary)):\n            if bit == '0': qc.x(i)\n        # Apply diffusion\n        qc = qc.compose(diffusion_operator(n))"
      },
      "tips": [
        "Don't over-iterate! Probability oscillates past the optimal point",
        "For unknown number of solutions, use quantum counting first",
        "Works with any initial state with non-zero solution overlap"
      ]
    },
    {
      "id": "phase_kickback",
      "title": "Phase Kickback",
      "symbol": "‚Ü©Ô∏è",
      "level": "intermediate",
      "definition": {
        "text": "Phase kickback is a key quantum phenomenon where a controlled operation's phase appears on the control qubit instead of the target. When the target is in an eigenstate of the controlled gate, applying CU gives U's eigenvalue as a phase to the control. This is essential for phase estimation, oracles, and many quantum algorithms.",
        "keyTerms": ["Phase Kickback", "Eigenstate", "Eigenvalue", "Controlled Gate", "Phase Estimation", "Ancilla"]
      },
      "keyFormulas": [
        {
          "id": "kickback_formula",
          "name": "Phase Kickback",
          "formula": "CU|+‚ü©|u‚ü© = (|0‚ü©|u‚ü© + e^(iœÜ)|1‚ü©|u‚ü©)/‚àö2",
          "latex": "CU|+\\rangle|u\\rangle = \\frac{|0\\rangle + e^{i\\phi}|1\\rangle}{\\sqrt{2}}|u\\rangle",
          "meaning": "Phase œÜ kicks back to control when U|u‚ü© = e^(iœÜ)|u‚ü©"
        }
      ],
      "examples": [
        {
          "id": "pk_ex1",
          "question": "What happens when we apply CNOT with target in |-‚ü© state?",
          "steps": [
            {"step": 1, "action": "Initial state", "result": "|+‚ü© ‚äó |-‚ü©", "explanation": "Control in |+‚ü©, target in |-‚ü©"},
            {"step": 2, "action": "Note that X|-‚ü© = -|-‚ü©", "result": "|-‚ü© is eigenstate of X with eigenvalue -1", "explanation": "X|-‚ü© = (|1‚ü©-|0‚ü©)/‚àö2 = -|-‚ü©"},
            {"step": 3, "action": "Apply CNOT", "result": "(|0‚ü©|-‚ü© + |1‚ü©(-|-‚ü©))/‚àö2 = |-‚ü© ‚äó |-‚ü©", "explanation": "Phase -1 kicks to control"}
          ],
          "finalAnswer": "CNOT with target |-‚ü© kicks phase to control: |+‚ü©|-‚ü© ‚Üí |-‚ü©|-‚ü©",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Phase Estimation", "description": "Extract eigenphases of unitaries"},
        {"title": "Grover Oracle", "description": "Convert bit-flip to phase-flip"},
        {"title": "Deutsch-Jozsa", "description": "Query function via phase kickback"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nfrom qiskit.quantum_info import Statevector\n\n# Demonstrate phase kickback with CNOT\nprint('Phase Kickback Demonstration')\nprint('=' * 40)\n\n# Setup: control in |+‚ü©, target in |-‚ü©\nqc = QuantumCircuit(2)\nqc.h(0)  # Control in |+‚ü©\nqc.x(1)  # Target in |1‚ü©\nqc.h(1)  # Target in |-‚ü©\n\nprint('Initial state: |+‚ü© ‚äó |-‚ü©')\nsv_before = Statevector.from_instruction(qc)\n\n# Apply CNOT\nqc.cx(0, 1)\n\nprint('After CNOT:')\nsv_after = Statevector.from_instruction(qc)\n\n# Check the control qubit state (trace out target)\nfrom qiskit.quantum_info import partial_trace, DensityMatrix\ndm = DensityMatrix(sv_after)\ncontrol_dm = partial_trace(dm, [1])\nprint(f'Control qubit density matrix:\\n{control_dm.data}')\nprint('\\nControl qubit is now |-‚ü© (phase kicked back!)')\n\n# Verify by measuring in X basis\nqc_measure = qc.copy()\nqc_measure.h(0)  # Convert |-‚ü© to |1‚ü©\nqc_measure.measure_all()\n\nsim = AerSimulator()\nresult = sim.run(transpile(qc_measure, sim), shots=1000).result()\nprint(f'\\nMeasuring control in X basis: {result.get_counts()}')\nprint('All |1‚ü© confirms control is in |-‚ü©')"
      },
      "tips": [
        "Phase kickback requires target in an eigenstate of the gate",
        "The eigenvalue becomes a relative phase on control qubit",
        "Use |-‚ü© = H|1‚ü© as target for converting X to Z phase"
      ]
    }
  ]
}
