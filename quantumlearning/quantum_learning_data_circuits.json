{
  "category": "Quantum Circuits",
  "categoryId": "circuits",
  "version": "1.0.0",
  "description": "Building and running quantum programs using quantum circuits",
  "icon": "point.3.connected.trianglepath.dotted",
  "color": "#14B8A6",
  "topics": [
    {
      "id": "circuit_model",
      "title": "Circuit Model",
      "symbol": "üìã",
      "level": "beginner",
      "definition": {
        "text": "The quantum circuit model is the standard computational model for quantum computing. Qubits start in |0‚ü©, gates are applied in sequence (left to right), and measurements extract classical outcomes. Time flows left to right, and each horizontal wire represents a qubit. This model is equivalent to other models like measurement-based or adiabatic quantum computing.",
        "keyTerms": ["Quantum Circuit", "Wire", "Gate", "Measurement", "Register", "Depth", "Width"]
      },
      "keyFormulas": [
        {
          "id": "circuit_state",
          "name": "Final State",
          "formula": "|œà_final‚ü© = U‚Çô...U‚ÇÇU‚ÇÅ|0‚ü©‚äó‚Åø",
          "latex": "|\\psi_{final}\\rangle = U_n \\cdots U_2 U_1 |0\\rangle^{\\otimes n}",
          "meaning": "Gates applied right-to-left in matrix order"
        }
      ],
      "examples": [
        {
          "id": "circuit_ex1",
          "question": "In a circuit, if H comes before X on the diagram, which is applied first to the state?",
          "steps": [
            {"step": 1, "action": "Read circuit left to right", "result": "H first, then X", "explanation": "Time flows left to right"},
            {"step": 2, "action": "Matrix multiplication", "result": "X(H|0‚ü©) = X|+‚ü©", "explanation": "Rightmost matrix first"},
            {"step": 3, "action": "Calculate", "result": "X|+‚ü© = (X|0‚ü©+X|1‚ü©)/‚àö2 = |+‚ü©", "explanation": "|+‚ü© is X eigenstate"}
          ],
          "finalAnswer": "H is applied first (circuit order), so X(H|0‚ü©) = X|+‚ü© = |+‚ü©",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum SDKs", "description": "Qiskit, Cirq, PennyLane use circuits"},
        {"title": "Quantum Hardware", "description": "Programs compiled to native gates"},
        {"title": "Algorithm Design", "description": "Standard way to describe quantum algorithms"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\n# Create a quantum circuit\nqc = QuantumCircuit(2, 2)  # 2 qubits, 2 classical bits\n\n# Build circuit (time flows left to right)\nqc.h(0)        # Hadamard on qubit 0\nqc.cx(0, 1)    # CNOT from 0 to 1\nqc.measure([0, 1], [0, 1])  # Measure both\n\nprint('Quantum Circuit:')\nprint(qc)\n\n# Circuit properties\nprint(f'\\nWidth (qubits): {qc.num_qubits}')\nprint(f'Depth: {qc.depth()}')\nprint(f'Gate count: {qc.size()}')\n\n# Run\nsim = AerSimulator()\nresult = sim.run(transpile(qc, sim), shots=1000).result()\nprint(f'\\nResults: {result.get_counts()}')"
      },
      "tips": [
        "Circuit diagram: time flows left to right",
        "Matrix multiplication: rightmost operator acts first",
        "Depth = longest path through the circuit"
      ]
    },
    {
      "id": "circuit_depth",
      "title": "Circuit Depth",
      "symbol": "üìè",
      "level": "intermediate",
      "definition": {
        "text": "Circuit depth is the number of time steps (layers) needed to execute a circuit, counting only the longest path of dependent gates. Shallow circuits (low depth) are preferred on NISQ devices because decoherence and errors accumulate with depth. Parallelizable gates on different qubits can run in the same layer.",
        "keyTerms": ["Depth", "Layer", "Parallelism", "Critical Path", "NISQ", "Decoherence", "T-depth"]
      },
      "keyFormulas": [
        {
          "id": "error_accumulation",
          "name": "Error Accumulation",
          "formula": "Error ‚âà 1 - (1-Œµ)^d ‚âà d√óŒµ for small Œµ",
          "latex": "\\text{Error} \\approx d \\times \\epsilon",
          "meaning": "d = depth, Œµ = gate error rate"
        }
      ],
      "examples": [
        {
          "id": "depth_ex1",
          "question": "What's the depth of: H(0), H(1), CNOT(0,1), H(0)?",
          "steps": [
            {"step": 1, "action": "Identify parallel gates", "result": "H(0) and H(1) can be layer 1", "explanation": "Different qubits"},
            {"step": 2, "action": "CNOT depends on H's", "result": "CNOT is layer 2", "explanation": "Must wait for H's"},
            {"step": 3, "action": "Final H(0)", "result": "H(0) is layer 3", "explanation": "Depends on CNOT"},
            {"step": 4, "action": "Count layers", "result": "Depth = 3", "explanation": "3 sequential layers"}
          ],
          "finalAnswer": "Depth = 3: [H(0),H(1)] ‚Üí [CNOT(0,1)] ‚Üí [H(0)]",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "NISQ Optimization", "description": "Minimize depth for noisy devices"},
        {"title": "Compilation", "description": "Optimize circuits for execution time"},
        {"title": "Error Analysis", "description": "Predict circuit fidelity"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit\n\n# Create circuits and compare depths\nqc1 = QuantumCircuit(3)\nqc1.h(0)\nqc1.h(1)\nqc1.h(2)  # All parallel\nprint(f'3 parallel H gates - Depth: {qc1.depth()}')\n\nqc2 = QuantumCircuit(3)\nqc2.h(0)\nqc2.cx(0, 1)\nqc2.cx(1, 2)  # Sequential CNOT chain\nprint(f'H + 2 sequential CNOTs - Depth: {qc2.depth()}')\n\n# Optimize depth with transpiler\nfrom qiskit import transpile\nfrom qiskit.providers.fake_provider import GenericBackendV2\n\nbackend = GenericBackendV2(3)\nqc_optimized = transpile(qc2, backend, optimization_level=3)\nprint(f'Optimized depth: {qc_optimized.depth()}')"
      },
      "tips": [
        "Gates on different qubits can often run in parallel",
        "T-depth counts only T gates (expensive in fault-tolerant)",
        "Depth √ó error rate gives rough infidelity estimate"
      ]
    },
    {
      "id": "oracle_circuits",
      "title": "Oracle Circuits",
      "symbol": "üîÆ",
      "level": "intermediate",
      "definition": {
        "text": "An oracle is a black-box unitary that encodes problem-specific information, typically marking solution states with a phase flip (phase oracle) or flipping an output qubit (bit oracle). Oracles are central to Grover's search and other query algorithms. While theoretical, practical implementations require explicit circuit construction for the specific function.",
        "keyTerms": ["Oracle", "Black Box", "Phase Oracle", "Bit Oracle", "Query Complexity", "Marking", "Function Encoding"]
      },
      "keyFormulas": [
        {
          "id": "phase_oracle",
          "name": "Phase Oracle",
          "formula": "O‚Çì|x‚ü© = (-1)^f(x)|x‚ü©",
          "latex": "O_x|x\\rangle = (-1)^{f(x)}|x\\rangle",
          "meaning": "Flips phase if f(x)=1"
        },
        {
          "id": "bit_oracle",
          "name": "Bit Oracle",
          "formula": "O‚Çì|x,y‚ü© = |x, y‚äïf(x)‚ü©",
          "latex": "O_x|x,y\\rangle = |x, y \\oplus f(x)\\rangle",
          "meaning": "XORs f(x) into ancilla"
        }
      ],
      "examples": [
        {
          "id": "oracle_ex1",
          "question": "Convert a bit oracle to a phase oracle",
          "steps": [
            {"step": 1, "action": "Prepare ancilla in |-‚ü©", "result": "Apply X then H to ancilla", "explanation": "|-‚ü© = (|0‚ü©-|1‚ü©)/‚àö2"},
            {"step": 2, "action": "Apply bit oracle", "result": "|x‚ü©|-‚ü© ‚Üí |x‚ü©(|f(x)‚ü©-|1‚äïf(x)‚ü©)/‚àö2", "explanation": "Phase kickback"},
            {"step": 3, "action": "If f(x)=0", "result": "(|0‚ü©-|1‚ü©)/‚àö2 = |-‚ü©", "explanation": "No change"},
            {"step": 4, "action": "If f(x)=1", "result": "(|1‚ü©-|0‚ü©)/‚àö2 = -|-‚ü©", "explanation": "Global phase of -1"}
          ],
          "finalAnswer": "Bit oracle + |-‚ü© ancilla gives phase kickback: |x‚ü©|-‚ü© ‚Üí (-1)^f(x)|x‚ü©|-‚ü©",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Grover's Algorithm", "description": "Oracle marks solutions"},
        {"title": "Quantum Walks", "description": "Oracle coins"},
        {"title": "Quantum Cryptography", "description": "Testing function properties"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit\nimport numpy as np\n\ndef phase_oracle(n, marked_states):\n    \"\"\"Create phase oracle marking specified states\"\"\"\n    qc = QuantumCircuit(n, name='Oracle')\n    \n    for marked in marked_states:\n        # Flip X gates for 0 bits\n        for i, bit in enumerate(reversed(bin(marked)[2:].zfill(n))):\n            if bit == '0':\n                qc.x(i)\n        \n        # Multi-controlled Z\n        if n == 1:\n            qc.z(0)\n        else:\n            qc.h(n-1)\n            qc.mcx(list(range(n-1)), n-1)\n            qc.h(n-1)\n        \n        # Uncompute X flips\n        for i, bit in enumerate(reversed(bin(marked)[2:].zfill(n))):\n            if bit == '0':\n                qc.x(i)\n    \n    return qc\n\n# Oracle marking |101‚ü© = 5\noracle = phase_oracle(3, [5])\nprint('Phase oracle for |101‚ü©:')\nprint(oracle)"
      },
      "tips": [
        "Oracles are problem-specific - must be constructed for each function",
        "Query complexity counts oracle calls, not gate count",
        "Phase kickback converts bit oracle to phase oracle"
      ]
    },
    {
      "id": "quantum_teleportation",
      "title": "Quantum Teleportation",
      "symbol": "üåÄ",
      "level": "intermediate",
      "definition": {
        "text": "Quantum teleportation transfers an unknown quantum state from sender (Alice) to receiver (Bob) using shared entanglement and classical communication. It requires: 1) A shared Bell pair, 2) Bell measurement by Alice, 3) Classical bits sent to Bob, 4) Bob applies corrections. The original state is destroyed (no-cloning respected). This is foundational for quantum networks and distributed quantum computing.",
        "keyTerms": ["Bell Pair", "Bell Measurement", "Classical Communication", "No-Cloning", "LOCC", "Quantum Channel", "Fidelity"]
      },
      "keyFormulas": [
        {
          "id": "teleport_state",
          "name": "Teleportation Protocol",
          "formula": "|œà‚ü© ‚äó |Œ¶+‚ü© ‚Üí classical bits ‚Üí |œà‚ü©",
          "latex": "|\\psi\\rangle \\otimes |\\Phi^+\\rangle \\xrightarrow{\\text{Bell meas.}} \\text{2 bits} \\xrightarrow{\\text{corrections}} |\\psi\\rangle",
          "meaning": "State + entanglement + 2 classical bits = teleportation"
        }
      ],
      "examples": [
        {
          "id": "teleport_ex1",
          "question": "Why can't we use teleportation for faster-than-light communication?",
          "steps": [
            {"step": 1, "action": "Alice measures", "result": "Gets random result (00, 01, 10, 11)", "explanation": "Measurement outcomes are random"},
            {"step": 2, "action": "Bob's qubit", "result": "Immediately in one of 4 states", "explanation": "Correlated with Alice's result"},
            {"step": 3, "action": "Without classical bits", "result": "Bob has random mixed state", "explanation": "No information extractable"},
            {"step": 4, "action": "Classical communication", "result": "Required for Bob to decode", "explanation": "Limited by speed of light"}
          ],
          "finalAnswer": "Classical communication is required to decode the state - without it, Bob has useless random results",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Internet", "description": "Foundation for quantum network communication"},
        {"title": "Distributed Quantum Computing", "description": "Connect quantum processors"},
        {"title": "Quantum Repeaters", "description": "Extend entanglement over long distances"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\ndef quantum_teleportation():\n    \"\"\"Demonstrate quantum teleportation circuit\"\"\"\n    qc = QuantumCircuit(3, 2)\n    \n    # Prepare state to teleport on qubit 0\n    # Example: |œà‚ü© = cos(œÄ/8)|0‚ü© + sin(œÄ/8)|1‚ü©\n    qc.ry(np.pi/4, 0)\n    qc.barrier()\n    \n    # Create Bell pair between qubits 1 and 2\n    qc.h(1)\n    qc.cx(1, 2)\n    qc.barrier()\n    \n    # Alice's Bell measurement (qubits 0 and 1)\n    qc.cx(0, 1)\n    qc.h(0)\n    qc.measure([0, 1], [0, 1])\n    qc.barrier()\n    \n    # Bob's corrections based on Alice's results\n    qc.x(2).c_if(1, 1)  # If qubit 1 measured 1\n    qc.z(2).c_if(0, 1)  # If qubit 0 measured 1\n    \n    print('Quantum Teleportation Circuit:')\n    print(qc)\n    return qc\n\nqc = quantum_teleportation()\n\n# Note: In real teleportation, we'd verify the state on qubit 2\n# matches the original state on qubit 0"
      },
      "tips": [
        "Teleportation requires both entanglement AND classical communication",
        "The original state is destroyed - no-cloning theorem is satisfied",
        "Bell measurement has 4 outcomes ‚Üí 2 classical bits needed"
      ]
    },
    {
      "id": "superdense_coding",
      "title": "Superdense Coding",
      "symbol": "üì¶",
      "level": "intermediate",
      "definition": {
        "text": "Superdense coding is the inverse of teleportation: it sends 2 classical bits using 1 qubit and shared entanglement. Alice applies one of four operations (I, X, Z, XZ) to her half of a Bell pair, then sends it to Bob. Bob performs a Bell measurement to decode both bits. This achieves the Holevo bound for quantum channel capacity with entanglement assistance.",
        "keyTerms": ["Holevo Bound", "Entanglement-Assisted", "Channel Capacity", "Bell State", "Dense Coding", "Quantum Communication"]
      },
      "keyFormulas": [
        {
          "id": "superdense_ops",
          "name": "Alice's Operations",
          "formula": "00‚ÜíI, 01‚ÜíX, 10‚ÜíZ, 11‚ÜíXZ",
          "latex": "00 \\to I, \\quad 01 \\to X, \\quad 10 \\to Z, \\quad 11 \\to XZ",
          "meaning": "Four Pauli operations encode 2 bits"
        }
      ],
      "examples": [
        {
          "id": "superdense_ex1",
          "question": "How does superdense coding double the classical capacity?",
          "steps": [
            {"step": 1, "action": "Shared Bell pair", "result": "|Œ¶+‚ü© = (|00‚ü©+|11‚ü©)/‚àö2", "explanation": "Pre-distributed entanglement"},
            {"step": 2, "action": "Alice encodes", "result": "I‚Üí|Œ¶+‚ü©, X‚Üí|Œ®+‚ü©, Z‚Üí|Œ¶-‚ü©, XZ‚Üí|Œ®-‚ü©", "explanation": "4 orthogonal Bell states"},
            {"step": 3, "action": "Alice sends 1 qubit", "result": "Bob has full Bell pair", "explanation": "One qubit transmitted"},
            {"step": 4, "action": "Bob decodes", "result": "Bell measurement gives 2 bits", "explanation": "4 outcomes = 2 bits"}
          ],
          "finalAnswer": "1 qubit sent + prior entanglement = 2 classical bits. But total quantum resources = 2 qubits.",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Networks", "description": "Efficient classical communication over quantum channels"},
        {"title": "Quantum Internet", "description": "Bandwidth optimization"},
        {"title": "Entanglement Distribution", "description": "Using pre-shared entanglement"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\ndef superdense_coding(bits):\n    \"\"\"Encode 2 classical bits into 1 qubit using superdense coding\"\"\"\n    qc = QuantumCircuit(2, 2)\n    \n    # Create Bell pair (pre-shared entanglement)\n    qc.h(0)\n    qc.cx(0, 1)\n    qc.barrier()\n    \n    # Alice's encoding on qubit 0\n    # bits: '00' = I, '01' = X, '10' = Z, '11' = XZ\n    if bits[1] == '1':  # First bit controls X\n        qc.x(0)\n    if bits[0] == '1':  # Second bit controls Z\n        qc.z(0)\n    qc.barrier()\n    \n    # Alice sends qubit 0 to Bob\n    # Bob's decoding (Bell measurement)\n    qc.cx(0, 1)\n    qc.h(0)\n    qc.measure([0, 1], [0, 1])\n    \n    return qc\n\n# Test all four cases\nsim = AerSimulator()\nfor bits in ['00', '01', '10', '11']:\n    qc = superdense_coding(bits)\n    result = sim.run(transpile(qc, sim), shots=1000).result()\n    print(f'Sent: {bits} ‚Üí Received: {result.get_counts()}')"
      },
      "tips": [
        "Superdense coding is the 'reverse' of teleportation",
        "Teleportation: 2 classical bits ‚Üí 1 qubit state",
        "Superdense: 1 qubit ‚Üí 2 classical bits (with entanglement)"
      ]
    },
    {
      "id": "variational_circuits",
      "title": "Variational Circuits",
      "symbol": "üîß",
      "level": "advanced",
      "definition": {
        "text": "Variational quantum circuits (VQCs) or parameterized quantum circuits (PQCs) are circuits with tunable rotation angles optimized classically. They form the core of NISQ algorithms like VQE (chemistry), QAOA (optimization), and quantum machine learning. The hybrid quantum-classical loop measures expectation values on quantum hardware while a classical optimizer adjusts parameters.",
        "keyTerms": ["VQE", "QAOA", "Ansatz", "Parameter Shift Rule", "Barren Plateaus", "Expressibility", "Entangling Layers"]
      },
      "keyFormulas": [
        {
          "id": "vqe_cost",
          "name": "VQE Cost Function",
          "formula": "E(Œ∏) = ‚ü®œà(Œ∏)|H|œà(Œ∏)‚ü©",
          "latex": "E(\\theta) = \\langle\\psi(\\theta)|H|\\psi(\\theta)\\rangle",
          "meaning": "Minimize energy to find ground state"
        },
        {
          "id": "param_shift",
          "name": "Parameter Shift Rule",
          "formula": "‚àÇE/‚àÇŒ∏ = [E(Œ∏+œÄ/2) - E(Œ∏-œÄ/2)] / 2",
          "latex": "\\frac{\\partial E}{\\partial \\theta} = \\frac{E(\\theta+\\pi/2) - E(\\theta-\\pi/2)}{2}",
          "meaning": "Gradient from two circuit evaluations"
        }
      ],
      "examples": [
        {
          "id": "vqc_ex1",
          "question": "Why are variational circuits suited for NISQ devices?",
          "steps": [
            {"step": 1, "action": "Shallow circuits", "result": "Low depth reduces decoherence", "explanation": "Fits coherence time"},
            {"step": 2, "action": "Hybrid approach", "result": "Heavy lifting on classical computer", "explanation": "Optimization is classical"},
            {"step": 3, "action": "Error tolerance", "result": "Expectation values average out some noise", "explanation": "Statistical robustness"},
            {"step": 4, "action": "Flexibility", "result": "Ansatz can adapt to hardware", "explanation": "Hardware-efficient circuits"}
          ],
          "finalAnswer": "Shallow depth + hybrid optimization + statistical averaging makes VQCs practical for noisy hardware",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Drug Discovery", "description": "VQE for molecular ground states"},
        {"title": "Optimization", "description": "QAOA for combinatorial problems"},
        {"title": "Machine Learning", "description": "Quantum neural networks"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit\nfrom qiskit.circuit import ParameterVector\nimport numpy as np\n\ndef hardware_efficient_ansatz(n_qubits, n_layers):\n    \"\"\"Create a hardware-efficient variational ansatz\"\"\"\n    params = ParameterVector('Œ∏', n_qubits * n_layers * 2)\n    qc = QuantumCircuit(n_qubits)\n    \n    p_idx = 0\n    for layer in range(n_layers):\n        # Rotation layer (RY and RZ on each qubit)\n        for qubit in range(n_qubits):\n            qc.ry(params[p_idx], qubit)\n            qc.rz(params[p_idx + 1], qubit)\n            p_idx += 2\n        \n        # Entangling layer (linear connectivity)\n        for qubit in range(n_qubits - 1):\n            qc.cx(qubit, qubit + 1)\n    \n    return qc, params\n\n# Create a 4-qubit, 2-layer ansatz\nansatz, params = hardware_efficient_ansatz(4, 2)\nprint(f'Variational Ansatz: {len(params)} parameters')\nprint(ansatz)\n\n# In a real VQE/QAOA:\n# 1. Bind random initial parameters\n# 2. Measure expectation value of Hamiltonian\n# 3. Classical optimizer updates parameters\n# 4. Repeat until convergence"
      },
      "tips": [
        "Watch out for barren plateaus - gradients vanish for deep random circuits",
        "Hardware-efficient ans√§tze use native gates of the device",
        "Parameter shift rule works for standard rotation gates"
      ]
    }
  ]
}

