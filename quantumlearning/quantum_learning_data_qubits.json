{
  "category": "Qubits",
  "categoryId": "qubits",
  "version": "1.0.0",
  "description": "Quantum bits - the fundamental unit of quantum information",
  "icon": "circle.hexagongrid",
  "color": "#8B5CF6",
  "topics": [
    {
      "id": "qubit_basics",
      "title": "Qubit Fundamentals",
      "symbol": "|œà‚ü©",
      "level": "beginner",
      "definition": {
        "text": "A qubit (quantum bit) is the fundamental unit of quantum information. Unlike a classical bit (0 or 1), a qubit can exist in a superposition of both states: |œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©, where Œ± and Œ≤ are complex probability amplitudes. The qubit is represented as a 2D complex vector in Hilbert space, and all operations are unitary transformations preserving the norm.",
        "keyTerms": ["Quantum Bit", "State Vector", "Hilbert Space", "Unitary", "Basis States", "Amplitude", "Two-Level System"]
      },
      "keyFormulas": [
        {
          "id": "qubit_general",
          "name": "General Qubit State",
          "formula": "|œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü© = [Œ±, Œ≤]·µÄ",
          "latex": "|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle = \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}",
          "meaning": "Œ±, Œ≤ ‚àà ‚ÑÇ with |Œ±|¬≤ + |Œ≤|¬≤ = 1"
        },
        {
          "id": "basis_states",
          "name": "Computational Basis",
          "formula": "|0‚ü© = [1, 0]·µÄ,  |1‚ü© = [0, 1]·µÄ",
          "latex": "|0\\rangle = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad |1\\rangle = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}",
          "meaning": "Standard basis vectors"
        }
      ],
      "examples": [
        {
          "id": "qubit_ex1",
          "question": "How many classical bits would you need to fully describe the state of 50 qubits?",
          "steps": [
            {"step": 1, "action": "Count quantum states", "result": "2‚Åµ‚Å∞ ‚âà 10¬π‚Åµ states", "explanation": "Each qubit doubles state space"},
            {"step": 2, "action": "Each amplitude is complex", "result": "2 √ó 2‚Åµ‚Å∞ real numbers needed", "explanation": "Real + imaginary parts"},
            {"step": 3, "action": "Estimate storage", "result": "~18 petabytes (at 64-bit precision)", "explanation": "More than most supercomputers' RAM"}
          ],
          "finalAnswer": "~18 petabytes - this is why we can't classically simulate large quantum systems!",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Memory", "description": "Storing quantum information"},
        {"title": "Quantum Networks", "description": "Transmitting qubits between nodes"},
        {"title": "Quantum Sensors", "description": "Using qubit sensitivity for measurement"}
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom qiskit.quantum_info import Statevector\n\n# Create basis states\nket_0 = np.array([1, 0])  # |0‚ü©\nket_1 = np.array([0, 1])  # |1‚ü©\n\nprint('Computational basis states:')\nprint(f'|0‚ü© = {ket_0}')\nprint(f'|1‚ü© = {ket_1}')\n\n# Create superposition state\nalpha = 1/np.sqrt(2)\nbeta = 1/np.sqrt(2)\npsi = alpha * ket_0 + beta * ket_1\n\nprint(f'\\n|+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2 = {psi}')\n\n# Verify normalization\nnorm = np.sum(np.abs(psi)**2)\nprint(f'Norm: {norm:.4f} (should be 1)')\n\n# Using Qiskit\nsv = Statevector.from_label('+')\nprint(f'\\nQiskit |+‚ü© state: {sv.data}')"
      },
      "tips": [
        "Think of qubits as arrows on a sphere (Bloch sphere), not as '0 and 1 at once'",
        "Physical qubits include: superconducting circuits, trapped ions, photons",
        "A single qubit has infinitely many possible states (continuous)"
      ]
    },
    {
      "id": "bloch_sphere",
      "title": "Bloch Sphere",
      "symbol": "üåê",
      "level": "beginner",
      "definition": {
        "text": "The Bloch sphere is a geometric representation of a single qubit's pure state as a point on a unit sphere. The north pole represents |0‚ü©, south pole represents |1‚ü©, and every other point represents a superposition. The sphere's angles Œ∏ (polar) and œÜ (azimuthal) parameterize all possible single-qubit states. Quantum gates correspond to rotations on this sphere.",
        "keyTerms": ["Polar Angle", "Azimuthal Angle", "North Pole", "South Pole", "Equator", "X-Y Plane", "Rotation"]
      },
      "keyFormulas": [
        {
          "id": "bloch_state",
          "name": "Bloch Sphere State",
          "formula": "|œà‚ü© = cos(Œ∏/2)|0‚ü© + e^(iœÜ)sin(Œ∏/2)|1‚ü©",
          "latex": "|\\psi\\rangle = \\cos\\frac{\\theta}{2}|0\\rangle + e^{i\\phi}\\sin\\frac{\\theta}{2}|1\\rangle",
          "meaning": "Œ∏ ‚àà [0,œÄ], œÜ ‚àà [0,2œÄ)"
        },
        {
          "id": "bloch_vector",
          "name": "Bloch Vector",
          "formula": "r‚Éó = (sin Œ∏ cos œÜ, sin Œ∏ sin œÜ, cos Œ∏)",
          "latex": "\\vec{r} = (\\sin\\theta\\cos\\phi, \\sin\\theta\\sin\\phi, \\cos\\theta)",
          "meaning": "Cartesian coordinates on unit sphere"
        }
      ],
      "examples": [
        {
          "id": "bloch_ex1",
          "question": "Where is the state |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2 on the Bloch sphere?",
          "steps": [
            {"step": 1, "action": "Compare to Bloch form", "result": "cos(Œ∏/2) = sin(Œ∏/2) = 1/‚àö2", "explanation": "Equal amplitudes"},
            {"step": 2, "action": "Solve for Œ∏", "result": "Œ∏/2 = œÄ/4, so Œ∏ = œÄ/2", "explanation": "Equator"},
            {"step": 3, "action": "Find œÜ", "result": "e^(iœÜ) = 1, so œÜ = 0", "explanation": "Positive X direction"}
          ],
          "finalAnswer": "|+‚ü© is on the equator, pointing in the +X direction (Œ∏=œÄ/2, œÜ=0)",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Visualizing Gates", "description": "Understanding rotations and operations"},
        {"title": "Debugging Circuits", "description": "Tracking state evolution visually"},
        {"title": "Teaching Quantum", "description": "Intuitive way to explain qubits"}
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom qiskit.visualization import plot_bloch_vector, plot_bloch_multivector\nfrom qiskit.quantum_info import Statevector\nimport matplotlib.pyplot as plt\n\n# Key states on Bloch sphere\nstates = {\n    '|0‚ü©': [0, 0, 1],      # North pole\n    '|1‚ü©': [0, 0, -1],     # South pole  \n    '|+‚ü©': [1, 0, 0],      # +X (equator)\n    '|-‚ü©': [-1, 0, 0],     # -X (equator)\n    '|i‚ü©': [0, 1, 0],      # +Y (equator)\n    '|-i‚ü©': [0, -1, 0],    # -Y (equator)\n}\n\n# Print Bloch coordinates\nprint('Bloch sphere coordinates (x, y, z):')\nfor name, coords in states.items():\n    print(f'{name}: {coords}')\n\n# Convert angles to state\ndef bloch_to_state(theta, phi):\n    \"\"\"Convert Bloch sphere angles to state vector\"\"\"\n    alpha = np.cos(theta/2)\n    beta = np.exp(1j*phi) * np.sin(theta/2)\n    return np.array([alpha, beta])\n\n# Example: |+‚ü© at Œ∏=œÄ/2, œÜ=0\ntheta, phi = np.pi/2, 0\nstate = bloch_to_state(theta, phi)\nprint(f'\\nŒ∏=œÄ/2, œÜ=0 gives state: {state}')\nprint('This is |+‚ü© = [1/‚àö2, 1/‚àö2]')"
      },
      "tips": [
        "Opposite points on the Bloch sphere are orthogonal states",
        "X, Y, Z gates rotate 180¬∞ around their respective axes",
        "The equator represents all equal superposition states (different phases)"
      ]
    },
    {
      "id": "dirac_notation",
      "title": "Dirac Notation",
      "symbol": "‚ü®œà|",
      "level": "beginner",
      "definition": {
        "text": "Dirac notation (bra-ket notation) is the standard notation for quantum mechanics and quantum computing. A 'ket' |œà‚ü© represents a column vector (state), a 'bra' ‚ü®œà| represents its conjugate transpose (row vector), and ‚ü®œÜ|œà‚ü© is the inner product. This notation makes quantum operations concise and elegant.",
        "keyTerms": ["Ket", "Bra", "Inner Product", "Outer Product", "Bracket", "Conjugate Transpose", "Dual Vector"]
      },
      "keyFormulas": [
        {
          "id": "ket",
          "name": "Ket (State Vector)",
          "formula": "|œà‚ü© = [Œ±, Œ≤]·µÄ",
          "latex": "|\\psi\\rangle = \\begin{pmatrix} \\alpha \\\\ \\beta \\end{pmatrix}",
          "meaning": "Column vector representing quantum state"
        },
        {
          "id": "bra",
          "name": "Bra (Dual Vector)",
          "formula": "‚ü®œà| = [Œ±*, Œ≤*]",
          "latex": "\\langle\\psi| = (\\alpha^*, \\beta^*)",
          "meaning": "Row vector, complex conjugate of ket"
        },
        {
          "id": "inner_product",
          "name": "Inner Product",
          "formula": "‚ü®œÜ|œà‚ü© = Œ£·µ¢ œÜ·µ¢*œà·µ¢",
          "latex": "\\langle\\phi|\\psi\\rangle = \\sum_i \\phi_i^* \\psi_i",
          "meaning": "Overlap/projection between states"
        },
        {
          "id": "outer_product",
          "name": "Outer Product",
          "formula": "|œà‚ü©‚ü®œÜ| = matrix",
          "latex": "|\\psi\\rangle\\langle\\phi|",
          "meaning": "Creates an operator/matrix"
        }
      ],
      "examples": [
        {
          "id": "dirac_ex1",
          "question": "Calculate ‚ü®0|+‚ü© where |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2",
          "steps": [
            {"step": 1, "action": "Write out bra and ket", "result": "‚ü®0| = [1, 0], |+‚ü© = [1, 1]·µÄ/‚àö2", "explanation": "Convert to vectors"},
            {"step": 2, "action": "Compute inner product", "result": "[1, 0] ¬∑ [1/‚àö2, 1/‚àö2]·µÄ", "explanation": "Row √ó column"},
            {"step": 3, "action": "Calculate", "result": "1¬∑(1/‚àö2) + 0¬∑(1/‚àö2) = 1/‚àö2", "explanation": "Dot product"}
          ],
          "finalAnswer": "‚ü®0|+‚ü© = 1/‚àö2 ‚âà 0.707",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Mechanics Papers", "description": "Standard notation in physics literature"},
        {"title": "Quantum Computing SDKs", "description": "Used in Qiskit, Cirq documentation"},
        {"title": "Quantum Algorithms", "description": "Describing operations symbolically"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\n# Define basis states (kets)\nket_0 = np.array([[1], [0]])  # |0‚ü©\nket_1 = np.array([[0], [1]])  # |1‚ü©\n\n# Bra is conjugate transpose\nbra_0 = ket_0.conj().T  # ‚ü®0|\nbra_1 = ket_1.conj().T  # ‚ü®1|\n\n# |+‚ü© state\nket_plus = (ket_0 + ket_1) / np.sqrt(2)\n\nprint('States:')\nprint(f'|0‚ü© = {ket_0.flatten()}')\nprint(f'|1‚ü© = {ket_1.flatten()}')\nprint(f'|+‚ü© = {ket_plus.flatten()}')\n\n# Inner products\nprint(f'\\nInner products:')\nprint(f'‚ü®0|0‚ü© = {(bra_0 @ ket_0)[0,0]:.0f}')\nprint(f'‚ü®0|1‚ü© = {(bra_0 @ ket_1)[0,0]:.0f}')\nprint(f'‚ü®0|+‚ü© = {(bra_0 @ ket_plus)[0,0]:.4f}')\nprint(f'‚ü®1|+‚ü© = {(bra_1 @ ket_plus)[0,0]:.4f}')\n\n# Outer product (creates projector)\nprint(f'\\nOuter product |0‚ü©‚ü®0|:')\nprint(ket_0 @ bra_0)"
      },
      "tips": [
        "‚ü®œà|œà‚ü© = 1 for normalized states (inner product with itself)",
        "‚ü®œÜ|œà‚ü© = 0 means the states are orthogonal (distinguishable)",
        "|œà‚ü©‚ü®œà| is a projector onto state |œà‚ü©"
      ]
    },
    {
      "id": "computational_basis",
      "title": "Computational Basis",
      "symbol": "|0‚ü©",
      "level": "beginner",
      "definition": {
        "text": "The computational basis {|0‚ü©, |1‚ü©} is the standard measurement basis in quantum computing, analogous to classical bits 0 and 1. All quantum states can be expressed as superpositions of these basis states. Quantum circuits typically start with qubits in |0‚ü© and end with measurement in this basis. Other common bases include X-basis {|+‚ü©, |-‚ü©} and Y-basis.",
        "keyTerms": ["Standard Basis", "Z-Basis", "Measurement Basis", "Eigenstate", "Pauli-Z", "Ground State", "Excited State"]
      },
      "keyFormulas": [
        {
          "id": "z_basis",
          "name": "Z-Basis (Computational)",
          "formula": "|0‚ü© = [1,0]·µÄ, |1‚ü© = [0,1]·µÄ",
          "latex": "|0\\rangle = \\begin{pmatrix}1\\\\0\\end{pmatrix}, |1\\rangle = \\begin{pmatrix}0\\\\1\\end{pmatrix}",
          "meaning": "Eigenstates of Pauli-Z"
        },
        {
          "id": "x_basis",
          "name": "X-Basis",
          "formula": "|+‚ü© = (|0‚ü©+|1‚ü©)/‚àö2, |-‚ü© = (|0‚ü©-|1‚ü©)/‚àö2",
          "latex": "|+\\rangle = \\frac{|0\\rangle+|1\\rangle}{\\sqrt{2}}, |-\\rangle = \\frac{|0\\rangle-|1\\rangle}{\\sqrt{2}}",
          "meaning": "Eigenstates of Pauli-X"
        },
        {
          "id": "y_basis",
          "name": "Y-Basis",
          "formula": "|i‚ü© = (|0‚ü©+i|1‚ü©)/‚àö2, |-i‚ü© = (|0‚ü©-i|1‚ü©)/‚àö2",
          "latex": "|i\\rangle = \\frac{|0\\rangle+i|1\\rangle}{\\sqrt{2}}, |-i\\rangle = \\frac{|0\\rangle-i|1\\rangle}{\\sqrt{2}}",
          "meaning": "Eigenstates of Pauli-Y"
        }
      ],
      "examples": [
        {
          "id": "basis_ex1",
          "question": "Express |+‚ü© in the X-basis and find measurement probabilities in X-basis",
          "steps": [
            {"step": 1, "action": "Identify X-basis", "result": "{|+‚ü©, |-‚ü©}", "explanation": "Eigenstates of X"},
            {"step": 2, "action": "Express |+‚ü©", "result": "|+‚ü© = 1¬∑|+‚ü© + 0¬∑|-‚ü©", "explanation": "|+‚ü© IS an X-basis state!"},
            {"step": 3, "action": "Calculate probabilities", "result": "P(+) = 1, P(-) = 0", "explanation": "Definite outcome"}
          ],
          "finalAnswer": "In X-basis: |+‚ü© gives 100% |+‚ü©, 0% |-‚ü© (no randomness)",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Qubit Readout", "description": "Standard measurement in quantum computers"},
        {"title": "Quantum Algorithms", "description": "Input/output in computational basis"},
        {"title": "Error Detection", "description": "Measuring ancilla qubits in Z-basis"}
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\n# Define all basis states\nbases = {\n    'Z-basis (computational)': {\n        '|0‚ü©': np.array([1, 0]),\n        '|1‚ü©': np.array([0, 1]),\n    },\n    'X-basis': {\n        '|+‚ü©': np.array([1, 1]) / np.sqrt(2),\n        '|-‚ü©': np.array([1, -1]) / np.sqrt(2),\n    },\n    'Y-basis': {\n        '|i‚ü©': np.array([1, 1j]) / np.sqrt(2),\n        '|-i‚ü©': np.array([1, -1j]) / np.sqrt(2),\n    }\n}\n\nfor basis_name, states in bases.items():\n    print(f'{basis_name}:')\n    for name, state in states.items():\n        print(f'  {name} = {state}')\n    print()\n\n# Measure |+‚ü© in different bases\nprint('Measuring |+‚ü© in different bases:')\n\n# Z-basis measurement\nqc_z = QuantumCircuit(1, 1)\nqc_z.h(0)  # Create |+‚ü©\nqc_z.measure(0, 0)\n\n# X-basis measurement (apply H before measure)\nqc_x = QuantumCircuit(1, 1)\nqc_x.h(0)  # Create |+‚ü©\nqc_x.h(0)  # Transform to Z-basis (H|+‚ü© = |0‚ü©)\nqc_x.measure(0, 0)\n\nsim = AerSimulator()\nprint(f'Z-basis: {sim.run(transpile(qc_z, sim), shots=1000).result().get_counts()}')\nprint(f'X-basis: {sim.run(transpile(qc_x, sim), shots=1000).result().get_counts()}')"
      },
      "tips": [
        "Z-basis: definite energy states (ground/excited)",
        "X-basis: definite phase states (in-phase/out-of-phase)",
        "To measure in X-basis: apply H, then measure in Z-basis"
      ]
    },
    {
      "id": "two_qubit_states",
      "title": "Two-Qubit States",
      "symbol": "|00‚ü©",
      "level": "intermediate",
      "definition": {
        "text": "Two-qubit systems have a 4-dimensional state space spanned by {|00‚ü©, |01‚ü©, |10‚ü©, |11‚ü©}. A general two-qubit state is |œà‚ü© = Œ±|00‚ü© + Œ≤|01‚ü© + Œ≥|10‚ü© + Œ¥|11‚ü© with |Œ±|¬≤ + |Œ≤|¬≤ + |Œ≥|¬≤ + |Œ¥|¬≤ = 1. Some states (like Bell states) are entangled and cannot be written as products of single-qubit states.",
        "keyTerms": ["Product State", "Entangled State", "Tensor Product", "State Space", "Two-Qubit Gate", "Correlation", "Separable"]
      },
      "keyFormulas": [
        {
          "id": "two_qubit_general",
          "name": "General Two-Qubit State",
          "formula": "|œà‚ü© = Œ±|00‚ü© + Œ≤|01‚ü© + Œ≥|10‚ü© + Œ¥|11‚ü©",
          "latex": "|\\psi\\rangle = \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle",
          "meaning": "4D complex vector with normalization"
        },
        {
          "id": "product_state",
          "name": "Product State",
          "formula": "|œà‚ÇÅ‚ü© ‚äó |œà‚ÇÇ‚ü© = (a|0‚ü©+b|1‚ü©) ‚äó (c|0‚ü©+d|1‚ü©)",
          "latex": "|\\psi_1\\rangle \\otimes |\\psi_2\\rangle",
          "meaning": "Separable (not entangled) state"
        }
      ],
      "examples": [
        {
          "id": "tq_ex1",
          "question": "Is the state |œà‚ü© = (|00‚ü© + |11‚ü©)/‚àö2 a product state or entangled?",
          "steps": [
            {"step": 1, "action": "Assume product form", "result": "(a|0‚ü©+b|1‚ü©)‚äó(c|0‚ü©+d|1‚ü©)", "explanation": "If separable"},
            {"step": 2, "action": "Expand", "result": "ac|00‚ü© + ad|01‚ü© + bc|10‚ü© + bd|11‚ü©", "explanation": "Four terms"},
            {"step": 3, "action": "Match coefficients", "result": "ac=1/‚àö2, ad=0, bc=0, bd=1/‚àö2", "explanation": "From |œà‚ü©"},
            {"step": 4, "action": "Check consistency", "result": "ad=0 implies a=0 or d=0, but ac‚â†0 and bd‚â†0 - contradiction!", "explanation": "No solution"}
          ],
          "finalAnswer": "Entangled! Cannot be written as a product state.",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Computing", "description": "Multi-qubit operations and algorithms"},
        {"title": "Quantum Teleportation", "description": "Requires entangled pairs"},
        {"title": "Quantum Error Correction", "description": "Encoding across multiple qubits"}
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom qiskit.quantum_info import Statevector\nfrom itertools import product\n\n# Two-qubit basis states\nbasis = ['00', '01', '10', '11']\nprint('Two-qubit computational basis:')\nfor b in basis:\n    sv = Statevector.from_label(b)\n    print(f'  |{b}‚ü© = {sv.data}')\n\n# Product state: |+‚ü© ‚äó |0‚ü©\nket_plus = np.array([1, 1]) / np.sqrt(2)\nket_0 = np.array([1, 0])\nproduct_state = np.kron(ket_plus, ket_0)\nprint(f'\\n|+‚ü© ‚äó |0‚ü© = {product_state}')\n\n# Bell state (entangled)\nbell_state = np.array([1, 0, 0, 1]) / np.sqrt(2)\nprint(f'|Œ¶‚Å∫‚ü© = (|00‚ü©+|11‚ü©)/‚àö2 = {bell_state}')\n\n# Check if product state via Schmidt decomposition\ndef is_product_state(state):\n    \"\"\"Check if 2-qubit state is separable\"\"\"\n    mat = state.reshape(2, 2)\n    u, s, vh = np.linalg.svd(mat)\n    return np.sum(s > 1e-10) == 1\n\nprint(f'\\n|+‚ü©‚äó|0‚ü© is product state: {is_product_state(product_state)}')\nprint(f'|Œ¶‚Å∫‚ü© is product state: {is_product_state(bell_state)}')"
      },
      "tips": [
        "n qubits have 2‚Åø dimensional state space",
        "Most two-qubit states are entangled (product states are measure-zero)",
        "Entanglement is necessary for quantum speedup"
      ]
    },
    {
      "id": "tensor_product",
      "title": "Tensor Product",
      "symbol": "‚äó",
      "level": "intermediate",
      "definition": {
        "text": "The tensor product ‚äó combines quantum systems into larger Hilbert spaces. For qubits: |œà‚ü© ‚äó |œÜ‚ü© creates a two-qubit state, and the dimension multiplies (2 √ó 2 = 4). For matrices/gates: A ‚äó B creates a larger operator. The Kronecker product is the matrix representation. Understanding tensor products is essential for multi-qubit quantum computing.",
        "keyTerms": ["Kronecker Product", "Composite System", "Hilbert Space", "Dimension", "Joint State", "Operator", "Identity Extension"]
      },
      "keyFormulas": [
        {
          "id": "tensor_vectors",
          "name": "Tensor Product of Vectors",
          "formula": "[a,b]·µÄ ‚äó [c,d]·µÄ = [ac,ad,bc,bd]·µÄ",
          "latex": "\\begin{pmatrix}a\\\\b\\end{pmatrix} \\otimes \\begin{pmatrix}c\\\\d\\end{pmatrix} = \\begin{pmatrix}ac\\\\ad\\\\bc\\\\bd\\end{pmatrix}",
          "meaning": "Creates 4D vector from two 2D vectors"
        },
        {
          "id": "tensor_matrices",
          "name": "Tensor Product of Matrices",
          "formula": "A ‚äó B: each element a·µ¢‚±º ‚Üí a·µ¢‚±º¬∑B",
          "latex": "A \\otimes B = \\begin{pmatrix}a_{11}B & a_{12}B \\\\ a_{21}B & a_{22}B\\end{pmatrix}",
          "meaning": "Block matrix construction"
        }
      ],
      "examples": [
        {
          "id": "tensor_ex1",
          "question": "Compute |0‚ü© ‚äó |+‚ü© explicitly",
          "steps": [
            {"step": 1, "action": "Write states as vectors", "result": "|0‚ü© = [1,0]·µÄ, |+‚ü© = [1,1]·µÄ/‚àö2", "explanation": "Column vectors"},
            {"step": 2, "action": "Apply tensor product", "result": "[1¬∑1/‚àö2, 1¬∑1/‚àö2, 0¬∑1/‚àö2, 0¬∑1/‚àö2]·µÄ", "explanation": "Kronecker product"},
            {"step": 3, "action": "Simplify", "result": "[1,1,0,0]·µÄ/‚àö2", "explanation": "= (|00‚ü©+|01‚ü©)/‚àö2"}
          ],
          "finalAnswer": "|0‚ü© ‚äó |+‚ü© = (|00‚ü© + |01‚ü©)/‚àö2",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Multi-Qubit Gates", "description": "Extending single-qubit gates to registers"},
        {"title": "Quantum Circuits", "description": "Parallel operations as tensor products"},
        {"title": "Quantum Simulation", "description": "Building many-body Hamiltonians"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\n# Tensor product of states\nket_0 = np.array([1, 0])\nket_1 = np.array([0, 1])\nket_plus = np.array([1, 1]) / np.sqrt(2)\n\n# |0‚ü© ‚äó |+‚ü©\nresult = np.kron(ket_0, ket_plus)\nprint('|0‚ü© ‚äó |+‚ü© =')\nprint(f'  {result}')\nprint(f'  = (|00‚ü© + |01‚ü©)/‚àö2')\n\n# Tensor product of gates\nI = np.eye(2)\nX = np.array([[0, 1], [1, 0]])\nH = np.array([[1, 1], [1, -1]]) / np.sqrt(2)\n\n# I ‚äó X (X on second qubit only)\nIX = np.kron(I, X)\nprint(f'\\nI ‚äó X (4√ó4 matrix):')\nprint(IX)\n\n# H ‚äó H (Hadamard on both qubits)\nHH = np.kron(H, H)\nprint(f'\\nH ‚äó H (4√ó4 matrix):')\nprint(np.round(HH, 3))"
      },
      "tips": [
        "np.kron() computes the Kronecker (tensor) product in NumPy",
        "Gate order: A ‚äó B means A acts on first qubit, B on second",
        "To apply gate G only to qubit 2 of 3: I ‚äó G ‚äó I"
      ]
    },
    {
      "id": "bell_states",
      "title": "Bell States",
      "symbol": "üîî",
      "level": "intermediate",
      "definition": {
        "text": "Bell states are the four maximally entangled two-qubit states, forming an orthonormal basis for the two-qubit Hilbert space. They are the fundamental resource for quantum teleportation, superdense coding, and entanglement-based protocols. Each Bell state exhibits perfect correlation or anti-correlation when both qubits are measured in the same basis.",
        "keyTerms": ["Maximally Entangled", "EPR Pair", "Bell Basis", "Teleportation", "Superdense Coding", "CHSH", "Non-locality"]
      },
      "keyFormulas": [
        {
          "id": "bell_phi_plus",
          "name": "Œ¶‚Å∫ (Phi Plus)",
          "formula": "|Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2",
          "latex": "|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}",
          "meaning": "Same outcome, positive phase"
        },
        {
          "id": "bell_phi_minus",
          "name": "Œ¶‚Åª (Phi Minus)",
          "formula": "|Œ¶‚Åª‚ü© = (|00‚ü© - |11‚ü©)/‚àö2",
          "latex": "|\\Phi^-\\rangle = \\frac{|00\\rangle - |11\\rangle}{\\sqrt{2}}",
          "meaning": "Same outcome, negative phase"
        },
        {
          "id": "bell_psi_plus",
          "name": "Œ®‚Å∫ (Psi Plus)",
          "formula": "|Œ®‚Å∫‚ü© = (|01‚ü© + |10‚ü©)/‚àö2",
          "latex": "|\\Psi^+\\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}}",
          "meaning": "Opposite outcomes, positive phase"
        },
        {
          "id": "bell_psi_minus",
          "name": "Œ®‚Åª (Psi Minus)",
          "formula": "|Œ®‚Åª‚ü© = (|01‚ü© - |10‚ü©)/‚àö2",
          "latex": "|\\Psi^-\\rangle = \\frac{|01\\rangle - |10\\rangle}{\\sqrt{2}}",
          "meaning": "Opposite outcomes, negative phase (singlet)"
        }
      ],
      "examples": [
        {
          "id": "bell_ex1",
          "question": "Create all four Bell states starting from |00‚ü© using just H and CNOT",
          "steps": [
            {"step": 1, "action": "Base circuit: H(0), CNOT(0,1)", "result": "|Œ¶‚Å∫‚ü© = (|00‚ü©+|11‚ü©)/‚àö2", "explanation": "Standard Bell state"},
            {"step": 2, "action": "Add X(0) before", "result": "|Œ¶‚Åª‚ü© = (|00‚ü©-|11‚ü©)/‚àö2", "explanation": "Start from |10‚ü©"},
            {"step": 3, "action": "Add X(1) before", "result": "|Œ®‚Å∫‚ü© = (|01‚ü©+|10‚ü©)/‚àö2", "explanation": "Start from |01‚ü©"},
            {"step": 4, "action": "Add X(0) and X(1) before", "result": "|Œ®‚Åª‚ü© = (|01‚ü©-|10‚ü©)/‚àö2", "explanation": "Start from |11‚ü©"}
          ],
          "finalAnswer": "H + CNOT creates Œ¶‚Å∫; adding X gates before changes which Bell state",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Teleportation", "description": "Transfer quantum states using entanglement"},
        {"title": "Quantum Key Distribution", "description": "E91 protocol uses Bell states"},
        {"title": "Bell Tests", "description": "Proving quantum non-locality"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\ndef create_bell_state(name):\n    \"\"\"Create a Bell state circuit\"\"\"\n    qc = QuantumCircuit(2, 2)\n    \n    # Prepare initial state based on Bell state desired\n    if name == 'Œ¶-' or name == 'Œ®-':\n        qc.x(0)  # Flip first qubit\n    if name == 'Œ®+' or name == 'Œ®-':\n        qc.x(1)  # Flip second qubit\n    \n    # Create entanglement\n    qc.h(0)\n    qc.cx(0, 1)\n    \n    return qc\n\n# Create and simulate all Bell states\nbell_states = ['Œ¶+', 'Œ¶-', 'Œ®+', 'Œ®-']\nsim = AerSimulator()\n\nprint('Bell State Measurement Results (1000 shots):')\nprint('=' * 45)\nfor name in bell_states:\n    qc = create_bell_state(name)\n    qc.measure([0, 1], [0, 1])\n    result = sim.run(transpile(qc, sim), shots=1000).result()\n    counts = result.get_counts()\n    print(f'|{name}‚ü©: {counts}')"
      },
      "tips": [
        "Bell states are the 'currency' of quantum information",
        "All four Bell states are equally entangled (maximal)",
        "The circuit H + CNOT creates Bell states from computational basis"
      ]
    },
    {
      "id": "density_matrix",
      "title": "Density Matrix",
      "symbol": "œÅ",
      "level": "advanced",
      "definition": {
        "text": "The density matrix œÅ generalizes the state vector to describe mixed states (statistical mixtures of pure states) and subsystems of entangled states. For a pure state |œà‚ü©, œÅ = |œà‚ü©‚ü®œà|. For a mixed state, œÅ = Œ£·µ¢ p·µ¢|œà·µ¢‚ü©‚ü®œà·µ¢| where p·µ¢ are classical probabilities. Density matrices enable description of decoherence, partial traces, and open quantum systems.",
        "keyTerms": ["Mixed State", "Pure State", "Trace", "Partial Trace", "Purity", "Von Neumann Entropy", "Reduced Density Matrix"]
      },
      "keyFormulas": [
        {
          "id": "pure_density",
          "name": "Pure State Density Matrix",
          "formula": "œÅ = |œà‚ü©‚ü®œà|",
          "latex": "\\rho = |\\psi\\rangle\\langle\\psi|",
          "meaning": "Outer product of state with itself"
        },
        {
          "id": "mixed_density",
          "name": "Mixed State",
          "formula": "œÅ = Œ£·µ¢ p·µ¢|œà·µ¢‚ü©‚ü®œà·µ¢|",
          "latex": "\\rho = \\sum_i p_i |\\psi_i\\rangle\\langle\\psi_i|",
          "meaning": "Classical mixture of pure states"
        },
        {
          "id": "purity",
          "name": "Purity",
          "formula": "Tr(œÅ¬≤) ‚â§ 1, equals 1 iff pure",
          "latex": "\\text{Tr}(\\rho^2) \\leq 1",
          "meaning": "Measure of how mixed the state is"
        },
        {
          "id": "expectation",
          "name": "Expectation Value",
          "formula": "‚ü®A‚ü© = Tr(œÅA)",
          "latex": "\\langle A \\rangle = \\text{Tr}(\\rho A)",
          "meaning": "Average of observable A in state œÅ"
        }
      ],
      "examples": [
        {
          "id": "dm_ex1",
          "question": "Calculate the density matrix and purity for a 50-50 mixture of |0‚ü© and |1‚ü©",
          "steps": [
            {"step": 1, "action": "Write mixture", "result": "œÅ = ¬Ω|0‚ü©‚ü®0| + ¬Ω|1‚ü©‚ü®1|", "explanation": "Classical 50-50 mixture"},
            {"step": 2, "action": "Calculate matrix", "result": "œÅ = [[¬Ω,0],[0,¬Ω]] = I/2", "explanation": "Maximally mixed"},
            {"step": 3, "action": "Calculate purity", "result": "Tr(œÅ¬≤) = Tr([[¬º,0],[0,¬º]]) = ¬Ω", "explanation": "Far from pure (would be 1)"}
          ],
          "finalAnswer": "œÅ = I/2 (identity over 2), Purity = 1/2 (maximally mixed for 1 qubit)",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Decoherence Modeling", "description": "Pure states becoming mixed"},
        {"title": "Quantum Channels", "description": "Describing noise and errors"},
        {"title": "Entanglement Measures", "description": "Partial traces and reduced states"}
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom qiskit.quantum_info import DensityMatrix, partial_trace, Statevector\n\n# Pure state density matrix\npsi = Statevector.from_label('+')\nrho_pure = DensityMatrix(psi)\n\nprint('Pure state |+‚ü©:')\nprint(f'  œÅ = {rho_pure.data}')\nprint(f'  Purity = {rho_pure.purity():.4f}')\n\n# Mixed state (50-50 mixture of |0‚ü© and |1‚ü©)\nrho_0 = DensityMatrix.from_label('0')\nrho_1 = DensityMatrix.from_label('1')\nrho_mixed = 0.5 * rho_0 + 0.5 * rho_1\n\nprint(f'\\nMixed state (50% |0‚ü© + 50% |1‚ü©):')\nprint(f'  œÅ = {rho_mixed.data}')\nprint(f'  Purity = {rho_mixed.purity():.4f}')\n\n# Reduced density matrix from Bell state\nbell = Statevector.from_label('00') + Statevector.from_label('11')\nbell = bell / np.sqrt(2)\nrho_bell = DensityMatrix(bell)\n\n# Trace out second qubit\nrho_reduced = partial_trace(rho_bell, [1])\nprint(f'\\nReduced density matrix of Bell state (traced out qubit 1):')\nprint(f'  œÅ = {rho_reduced.data}')\nprint(f'  Purity = {rho_reduced.purity():.4f}')\nprint('  (Maximally mixed - signature of entanglement!)')"
      },
      "tips": [
        "Pure states: œÅ¬≤ = œÅ (projector), Tr(œÅ¬≤) = 1",
        "Maximally mixed: œÅ = I/d for d-dimensional system",
        "Partial trace reveals entanglement: entangled states give mixed reduced density matrices"
      ]
    }
  ]
}

