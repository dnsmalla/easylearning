{
  "category": "Quantum Basics",
  "categoryId": "basics",
  "version": "1.0.0",
  "description": "Fundamental quantum mechanics concepts that form the foundation of quantum computing",
  "icon": "atom",
  "color": "#6366F1",
  "topics": [
    {
      "id": "what_is_quantum",
      "title": "What is Quantum Computing?",
      "symbol": "üîÆ",
      "level": "beginner",
      "definition": {
        "text": "Quantum computing harnesses quantum mechanical phenomena like superposition and entanglement to process information in fundamentally new ways. Unlike classical bits (0 or 1), quantum bits (qubits) can exist in superpositions, enabling parallel exploration of solution spaces. This enables exponential speedups for certain problems like factoring, search, and simulation of quantum systems.",
        "keyTerms": ["Qubit", "Superposition", "Entanglement", "Quantum Advantage", "Quantum Supremacy", "NISQ", "Fault-Tolerant"]
      },
      "keyFormulas": [
        {
          "id": "qubit_state",
          "name": "General Qubit State",
          "formula": "|œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©",
          "latex": "|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle",
          "meaning": "Œ±, Œ≤ are complex amplitudes where |Œ±|¬≤ + |Œ≤|¬≤ = 1"
        }
      ],
      "examples": [
        {
          "id": "qc_ex1",
          "question": "Why can a quantum computer be faster than a classical computer for certain problems?",
          "steps": [
            {"step": 1, "action": "Understand superposition", "result": "1 qubit = 2 states simultaneously", "explanation": "|0‚ü© and |1‚ü© at once"},
            {"step": 2, "action": "Scale to n qubits", "result": "n qubits = 2^n states simultaneously", "explanation": "Exponential parallelism"},
            {"step": 3, "action": "Apply quantum algorithms", "result": "Interference amplifies correct answers", "explanation": "Wrong answers cancel out"}
          ],
          "finalAnswer": "Quantum parallelism allows exploring 2^n states at once, with interference to extract useful results",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Drug Discovery", "description": "Simulating molecular interactions for new medicines"},
        {"title": "Cryptography", "description": "Breaking RSA encryption, quantum key distribution"},
        {"title": "Optimization", "description": "Logistics, portfolio optimization, machine learning"}
      ],
      "codeExample": {
        "python": "# Simple quantum circuit with Qiskit\nfrom qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\n# Create a quantum circuit with 2 qubits\nqc = QuantumCircuit(2, 2)\n\n# Put first qubit in superposition\nqc.h(0)\n\n# Create entanglement with CNOT\nqc.cx(0, 1)\n\n# Measure both qubits\nqc.measure([0, 1], [0, 1])\n\n# Simulate\nsimulator = AerSimulator()\ncompiled = transpile(qc, simulator)\nresult = simulator.run(compiled, shots=1000).result()\ncounts = result.get_counts()\nprint(f'Results: {counts}')\n# Output: {'00': ~500, '11': ~500}"
      },
      "tips": [
        "Start with linear algebra basics: vectors, matrices, complex numbers",
        "Use IBM Quantum or Google Cirq for hands-on experience",
        "Quantum advantage doesn't mean faster for all problems - focus on specific use cases"
      ]
    },
    {
      "id": "wave_particle_duality",
      "title": "Wave-Particle Duality",
      "symbol": "üåä",
      "level": "beginner",
      "definition": {
        "text": "Wave-particle duality is the fundamental concept that quantum objects exhibit both wave-like and particle-like properties. Electrons, photons, and even atoms show interference patterns (wave behavior) when not observed, but appear as discrete particles when measured. This duality is central to understanding why quantum systems behave probabilistically.",
        "keyTerms": ["Double-Slit Experiment", "de Broglie Wavelength", "Complementarity", "Interference", "Diffraction", "Matter Waves"]
      },
      "keyFormulas": [
        {
          "id": "de_broglie",
          "name": "de Broglie Wavelength",
          "formula": "Œª = h/p = h/(mv)",
          "latex": "\\lambda = \\frac{h}{p} = \\frac{h}{mv}",
          "meaning": "h = Planck's constant, p = momentum, m = mass, v = velocity"
        },
        {
          "id": "planck",
          "name": "Planck's Constant",
          "formula": "h = 6.626 √ó 10‚Åª¬≥‚Å¥ J¬∑s",
          "latex": "h = 6.626 \\times 10^{-34} \\text{ J}\\cdot\\text{s}",
          "meaning": "Fundamental quantum of action"
        }
      ],
      "examples": [
        {
          "id": "wpd_ex1",
          "question": "Calculate the de Broglie wavelength of an electron moving at 1% the speed of light",
          "steps": [
            {"step": 1, "action": "Identify values", "result": "m = 9.11√ó10‚Åª¬≥¬π kg, v = 3√ó10‚Å∂ m/s", "explanation": "Electron mass and 1% of c"},
            {"step": 2, "action": "Calculate momentum", "result": "p = mv = 2.73√ó10‚Åª¬≤‚Å¥ kg¬∑m/s", "explanation": "Classical momentum"},
            {"step": 3, "action": "Apply de Broglie formula", "result": "Œª = h/p = 2.43√ó10‚Åª¬π‚Å∞ m", "explanation": "About 0.24 nanometers"}
          ],
          "finalAnswer": "Œª ‚âà 0.24 nm (similar to atomic spacing in crystals)",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Electron Microscopy", "description": "Using electron waves for high-resolution imaging"},
        {"title": "Quantum Interference", "description": "Foundation for quantum computing gates"},
        {"title": "Semiconductors", "description": "Electron wave behavior in transistors"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\n# Physical constants\nh = 6.626e-34  # Planck's constant (J¬∑s)\nc = 3e8        # Speed of light (m/s)\nm_e = 9.11e-31 # Electron mass (kg)\n\ndef de_broglie_wavelength(mass, velocity):\n    \"\"\"Calculate de Broglie wavelength\"\"\"\n    momentum = mass * velocity\n    wavelength = h / momentum\n    return wavelength\n\n# Example: electron at 1% speed of light\nv = 0.01 * c\nlambda_e = de_broglie_wavelength(m_e, v)\n\nprint(f'Electron velocity: {v:.2e} m/s')\nprint(f'de Broglie wavelength: {lambda_e:.2e} m')\nprint(f'                     = {lambda_e*1e9:.2f} nm')\n\n# Compare with photon of same wavelength\nE_photon = h * c / lambda_e\nprint(f'Photon energy (same Œª): {E_photon:.2e} J')\nprint(f'                      = {E_photon/1.6e-19:.1f} eV')"
      },
      "tips": [
        "The wave nature is only significant when Œª is comparable to the system size",
        "Massive objects have extremely tiny wavelengths - that's why we don't see quantum effects daily",
        "Observation doesn't require consciousness - any interaction with the environment counts"
      ]
    },
    {
      "id": "superposition",
      "title": "Superposition",
      "symbol": "‚ûï",
      "level": "beginner",
      "definition": {
        "text": "Superposition is the quantum mechanical principle where a quantum system exists in multiple states simultaneously until measured. A qubit in superposition is both |0‚ü© and |1‚ü© at the same time, described by complex probability amplitudes. Upon measurement, the superposition 'collapses' to a definite state with probability given by the squared amplitude.",
        "keyTerms": ["Quantum State", "Probability Amplitude", "State Vector", "Collapse", "Coherence", "Interference", "Hadamard Gate"]
      },
      "keyFormulas": [
        {
          "id": "superposition_state",
          "name": "Superposition State",
          "formula": "|œà‚ü© = Œ±|0‚ü© + Œ≤|1‚ü©",
          "latex": "|\\psi\\rangle = \\alpha|0\\rangle + \\beta|1\\rangle",
          "meaning": "Œ±, Œ≤ ‚àà ‚ÑÇ with |Œ±|¬≤ + |Œ≤|¬≤ = 1"
        },
        {
          "id": "born_rule",
          "name": "Born Rule",
          "formula": "P(0) = |Œ±|¬≤, P(1) = |Œ≤|¬≤",
          "latex": "P(|0\\rangle) = |\\alpha|^2, \\quad P(|1\\rangle) = |\\beta|^2",
          "meaning": "Probability = |amplitude|¬≤"
        },
        {
          "id": "plus_state",
          "name": "Plus State",
          "formula": "|+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2",
          "latex": "|+\\rangle = \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}",
          "meaning": "Equal superposition (50% chance each)"
        }
      ],
      "examples": [
        {
          "id": "sup_ex1",
          "question": "A qubit is in state |œà‚ü© = (3|0‚ü© + 4i|1‚ü©)/5. What's the probability of measuring |1‚ü©?",
          "steps": [
            {"step": 1, "action": "Identify amplitude of |1‚ü©", "result": "Œ≤ = 4i/5", "explanation": "Complex amplitude"},
            {"step": 2, "action": "Apply Born rule", "result": "|Œ≤|¬≤ = |4i/5|¬≤ = 16/25", "explanation": "|4i| = 4"},
            {"step": 3, "action": "Calculate probability", "result": "P(1) = 16/25 = 0.64 = 64%", "explanation": "64% chance of |1‚ü©"}
          ],
          "finalAnswer": "P(|1‚ü©) = 64%",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Parallelism", "description": "Evaluate function on all inputs simultaneously"},
        {"title": "Quantum Random Number Generation", "description": "True randomness from measurement"},
        {"title": "Quantum Sensing", "description": "Enhanced measurement precision"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\nimport numpy as np\n\n# Create a qubit in |0‚ü©\nqc = QuantumCircuit(1, 1)\n\n# Apply Hadamard to create |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2\nqc.h(0)\nprint('State after Hadamard: |+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2')\n\n# Measure\nqc.measure(0, 0)\n\n# Simulate many shots\nsimulator = AerSimulator()\ncompiled = transpile(qc, simulator)\nresult = simulator.run(compiled, shots=10000).result()\ncounts = result.get_counts()\n\nprint(f'\\nMeasurement results (10000 shots):')\nfor state, count in counts.items():\n    print(f'  |{state}‚ü©: {count} ({100*count/10000:.1f}%)')\n\n# Verify ~50-50 split (superposition)\nprint('\\nExpected: ~50% |0‚ü©, ~50% |1‚ü©')"
      },
      "tips": [
        "Superposition is not 'being in both states' - it's a fundamentally different state",
        "The Hadamard gate H is the key to creating superposition from |0‚ü© or |1‚ü©",
        "Measurement destroys superposition - you can't observe it directly"
      ]
    },
    {
      "id": "entanglement",
      "title": "Quantum Entanglement",
      "symbol": "üîó",
      "level": "beginner",
      "definition": {
        "text": "Entanglement is a quantum correlation between two or more particles where measuring one instantly determines the state of the other, regardless of distance. Einstein called it 'spooky action at a distance.' Entangled states cannot be described as products of individual states - they are fundamentally non-separable. Bell states are maximally entangled two-qubit states.",
        "keyTerms": ["EPR Paradox", "Bell States", "Non-locality", "Bell Inequality", "CHSH Inequality", "Separable States", "Entanglement Entropy"]
      },
      "keyFormulas": [
        {
          "id": "bell_phi_plus",
          "name": "Bell State Œ¶‚Å∫",
          "formula": "|Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2",
          "latex": "|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}",
          "meaning": "Measuring one qubit instantly determines the other"
        },
        {
          "id": "bell_psi_plus",
          "name": "Bell State Œ®‚Å∫",
          "formula": "|Œ®‚Å∫‚ü© = (|01‚ü© + |10‚ü©)/‚àö2",
          "latex": "|\\Psi^+\\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}}",
          "meaning": "Anti-correlated entanglement"
        }
      ],
      "examples": [
        {
          "id": "ent_ex1",
          "question": "Two qubits are in state |Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2. Alice measures qubit 1 and gets |0‚ü©. What does Bob's qubit collapse to?",
          "steps": [
            {"step": 1, "action": "Initial state", "result": "|Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2", "explanation": "50% |00‚ü©, 50% |11‚ü©"},
            {"step": 2, "action": "Alice measures |0‚ü©", "result": "Only |00‚ü© term survives", "explanation": "|11‚ü© has first qubit = 1, eliminated"},
            {"step": 3, "action": "State collapses", "result": "Bob's qubit is |0‚ü©", "explanation": "Perfect correlation"}
          ],
          "finalAnswer": "Bob's qubit is definitely |0‚ü© (100% certainty)",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Key Distribution", "description": "Secure communication using entanglement"},
        {"title": "Quantum Teleportation", "description": "Transferring quantum states"},
        {"title": "Distributed Quantum Computing", "description": "Linking quantum processors"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\n# Create Bell state |Œ¶‚Å∫‚ü©\nqc = QuantumCircuit(2, 2)\n\n# Step 1: Hadamard on qubit 0\nqc.h(0)\n\n# Step 2: CNOT with qubit 0 as control, qubit 1 as target\nqc.cx(0, 1)\n\n# Now we have |Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2\nprint('Created Bell state |Œ¶‚Å∫‚ü© = (|00‚ü© + |11‚ü©)/‚àö2')\n\n# Measure both qubits\nqc.measure([0, 1], [0, 1])\n\n# Simulate\nsimulator = AerSimulator()\ncompiled = transpile(qc, simulator)\nresult = simulator.run(compiled, shots=10000).result()\ncounts = result.get_counts()\n\nprint(f'\\nMeasurement results:')\nfor state, count in sorted(counts.items()):\n    print(f'  |{state}‚ü©: {count} ({100*count/10000:.1f}%)')\n\nprint('\\nNote: Only |00‚ü© and |11‚ü© - qubits always correlated!')"
      },
      "tips": [
        "Entanglement doesn't allow faster-than-light communication",
        "H + CNOT is the standard circuit to create Bell states",
        "Entanglement is a resource that gets consumed when used"
      ]
    },
    {
      "id": "measurement",
      "title": "Quantum Measurement",
      "symbol": "üìè",
      "level": "beginner",
      "definition": {
        "text": "Quantum measurement irreversibly extracts classical information from a quantum system. Upon measurement, a superposition collapses to one of the basis states with probability given by the Born rule. The choice of measurement basis affects outcomes - measuring in different bases reveals different information. This is fundamental to quantum computing and the source of 'quantum randomness.'",
        "keyTerms": ["Born Rule", "Collapse", "Projective Measurement", "Measurement Basis", "Observable", "POVM", "Weak Measurement"]
      },
      "keyFormulas": [
        {
          "id": "born_probability",
          "name": "Born Rule",
          "formula": "P(m) = |‚ü®m|œà‚ü©|¬≤",
          "latex": "P(m) = |\\langle m|\\psi\\rangle|^2",
          "meaning": "Probability = |inner product with measurement basis|¬≤"
        },
        {
          "id": "post_measurement",
          "name": "Post-Measurement State",
          "formula": "|œà'‚ü© = |m‚ü©",
          "latex": "|\\psi'\\rangle = |m\\rangle",
          "meaning": "State collapses to measured outcome"
        }
      ],
      "examples": [
        {
          "id": "meas_ex1",
          "question": "Qubit is in |+‚ü© state. What happens if measured in Z basis vs X basis?",
          "steps": [
            {"step": 1, "action": "Express |+‚ü©", "result": "|+‚ü© = (|0‚ü© + |1‚ü©)/‚àö2", "explanation": "Equal superposition in Z basis"},
            {"step": 2, "action": "Z-basis measurement", "result": "50% |0‚ü©, 50% |1‚ü©", "explanation": "Random outcome"},
            {"step": 3, "action": "X-basis measurement", "result": "100% |+‚ü©", "explanation": "|+‚ü© IS an X-basis eigenstate"}
          ],
          "finalAnswer": "Z-basis: random. X-basis: always |+‚ü©. Measurement basis matters!",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum Readout", "description": "Getting results from quantum computers"},
        {"title": "Quantum Random Number Generation", "description": "True randomness"},
        {"title": "Quantum State Tomography", "description": "Reconstructing unknown quantum states"}
      ],
      "codeExample": {
        "python": "from qiskit import QuantumCircuit, transpile\nfrom qiskit_aer import AerSimulator\n\n# Create |+‚ü© state\nqc_z = QuantumCircuit(1, 1)\nqc_z.h(0)  # Creates |+‚ü©\nqc_z.measure(0, 0)  # Z-basis measurement\n\n# Same but measure in X-basis\nqc_x = QuantumCircuit(1, 1)\nqc_x.h(0)  # Creates |+‚ü©\nqc_x.h(0)  # Rotate to X-basis (H before measure)\nqc_x.measure(0, 0)\n\n# Simulate both\nsimulator = AerSimulator()\n\nprint('Z-basis measurement of |+‚ü©:')\nresult_z = simulator.run(transpile(qc_z, simulator), shots=1000).result()\nprint(f'  {result_z.get_counts()}')\nprint('  Expected: ~50% |0‚ü©, ~50% |1‚ü©\\n')\n\nprint('X-basis measurement of |+‚ü©:')\nresult_x = simulator.run(transpile(qc_x, simulator), shots=1000).result()\nprint(f'  {result_x.get_counts()}')\nprint('  Expected: 100% |0‚ü© (which represents |+‚ü©)')"
      },
      "tips": [
        "Measurement is irreversible - quantum information is lost",
        "The measurement basis determines what outcomes are possible",
        "Multiple qubits can be measured independently or together"
      ]
    },
    {
      "id": "uncertainty",
      "title": "Heisenberg Uncertainty Principle",
      "symbol": "‚öñÔ∏è",
      "level": "intermediate",
      "definition": {
        "text": "The Heisenberg Uncertainty Principle states that certain pairs of physical properties (like position and momentum) cannot both be known precisely. This isn't a measurement limitation but a fundamental property of nature. For quantum computing, incompatible observables (non-commuting operators) exhibit uncertainty relations, meaning precise knowledge of one limits knowledge of the other.",
        "keyTerms": ["Conjugate Variables", "Commutator", "Position-Momentum", "Energy-Time", "Observable", "Standard Deviation"]
      },
      "keyFormulas": [
        {
          "id": "uncertainty_xp",
          "name": "Position-Momentum Uncertainty",
          "formula": "Œîx¬∑Œîp ‚â• ‚Ñè/2",
          "latex": "\\Delta x \\cdot \\Delta p \\geq \\frac{\\hbar}{2}",
          "meaning": "‚Ñè = h/(2œÄ) ‚âà 1.055 √ó 10‚Åª¬≥‚Å¥ J¬∑s"
        },
        {
          "id": "uncertainty_Et",
          "name": "Energy-Time Uncertainty",
          "formula": "ŒîE¬∑Œît ‚â• ‚Ñè/2",
          "latex": "\\Delta E \\cdot \\Delta t \\geq \\frac{\\hbar}{2}",
          "meaning": "Short-lived states have energy uncertainty"
        },
        {
          "id": "commutator",
          "name": "Commutator Relation",
          "formula": "[X, P] = i‚Ñè",
          "latex": "[\\hat{X}, \\hat{P}] = i\\hbar",
          "meaning": "Non-zero commutator implies uncertainty"
        }
      ],
      "examples": [
        {
          "id": "unc_ex1",
          "question": "If an electron is localized to within 1 nm, what's the minimum uncertainty in its velocity?",
          "steps": [
            {"step": 1, "action": "Given Œîx = 1 nm = 10‚Åª‚Åπ m", "result": "Apply Œîx¬∑Œîp ‚â• ‚Ñè/2", "explanation": "Position uncertainty given"},
            {"step": 2, "action": "Calculate Œîp", "result": "Œîp ‚â• ‚Ñè/(2Œîx) = 5.27√ó10‚Åª¬≤‚Å∂ kg¬∑m/s", "explanation": "Minimum momentum uncertainty"},
            {"step": 3, "action": "Find Œîv = Œîp/m", "result": "Œîv ‚â• 5.8√ó10‚Å¥ m/s", "explanation": "Using electron mass"}
          ],
          "finalAnswer": "Œîv ‚â• 58 km/s - that's 0.02% of the speed of light!",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Electron Microscopy", "description": "Resolution limits from uncertainty"},
        {"title": "Quantum Tunneling", "description": "Particles can pass through barriers"},
        {"title": "Vacuum Fluctuations", "description": "Virtual particles from energy-time uncertainty"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\n# Physical constants\nhbar = 1.055e-34  # Reduced Planck constant (J¬∑s)\nm_e = 9.11e-31    # Electron mass (kg)\n\ndef minimum_momentum_uncertainty(delta_x):\n    \"\"\"Calculate minimum Œîp from uncertainty principle\"\"\"\n    return hbar / (2 * delta_x)\n\ndef minimum_velocity_uncertainty(delta_x, mass):\n    \"\"\"Calculate minimum Œîv from uncertainty principle\"\"\"\n    delta_p = minimum_momentum_uncertainty(delta_x)\n    return delta_p / mass\n\n# Example: electron localized to 1 nm\ndelta_x = 1e-9  # 1 nanometer\n\ndelta_p = minimum_momentum_uncertainty(delta_x)\ndelta_v = minimum_velocity_uncertainty(delta_x, m_e)\n\nprint(f'Position uncertainty: Œîx = {delta_x*1e9:.1f} nm')\nprint(f'Minimum momentum uncertainty: Œîp ‚â• {delta_p:.2e} kg¬∑m/s')\nprint(f'Minimum velocity uncertainty: Œîv ‚â• {delta_v:.2e} m/s')\nprint(f'                            = {delta_v/1000:.1f} km/s')\nprint(f'\\nAs fraction of speed of light: {100*delta_v/3e8:.3f}%')"
      },
      "tips": [
        "Uncertainty is not about measurement error - it's fundamental",
        "Only applies to non-commuting observables (conjugate pairs)",
        "In quantum computing: Z and X observables don't commute"
      ]
    },
    {
      "id": "wave_function",
      "title": "Wave Function",
      "symbol": "œà",
      "level": "intermediate",
      "definition": {
        "text": "The wave function œà(x,t) is the complete mathematical description of a quantum system's state. Its squared magnitude |œà|¬≤ gives the probability density of finding the particle at position x. Wave functions must be normalized (total probability = 1), continuous, and single-valued. In quantum computing, we work with discrete state vectors |œà‚ü© rather than continuous wave functions.",
        "keyTerms": ["State Vector", "Probability Density", "Normalization", "Hilbert Space", "Schr√∂dinger Equation", "Ket", "Bra"]
      },
      "keyFormulas": [
        {
          "id": "normalization",
          "name": "Normalization",
          "formula": "‚à´|œà(x)|¬≤ dx = 1",
          "latex": "\\int_{-\\infty}^{\\infty} |\\psi(x)|^2 \\, dx = 1",
          "meaning": "Total probability must equal 1"
        },
        {
          "id": "discrete_norm",
          "name": "Discrete Normalization",
          "formula": "Œ£·µ¢|Œ±·µ¢|¬≤ = 1",
          "latex": "\\sum_i |\\alpha_i|^2 = 1",
          "meaning": "For qubit states with amplitudes Œ±·µ¢"
        },
        {
          "id": "inner_product",
          "name": "Inner Product",
          "formula": "‚ü®œà|œÜ‚ü© = Œ£·µ¢ Œ±·µ¢*Œ≤·µ¢",
          "latex": "\\langle\\psi|\\phi\\rangle = \\sum_i \\alpha_i^* \\beta_i",
          "meaning": "Overlap between two states"
        }
      ],
      "examples": [
        {
          "id": "wf_ex1",
          "question": "Normalize the state |œà‚ü© = 3|0‚ü© + 4|1‚ü©",
          "steps": [
            {"step": 1, "action": "Calculate norm", "result": "||œà||¬≤ = |3|¬≤ + |4|¬≤ = 9 + 16 = 25", "explanation": "Sum of squared amplitudes"},
            {"step": 2, "action": "Find normalization factor", "result": "N = ‚àö25 = 5", "explanation": "Divide by this to normalize"},
            {"step": 3, "action": "Normalize", "result": "|œà‚ü© = (3|0‚ü© + 4|1‚ü©)/5", "explanation": "Now |3/5|¬≤ + |4/5|¬≤ = 1"}
          ],
          "finalAnswer": "|œà‚ü© = (3|0‚ü© + 4|1‚ü©)/5 with P(0)=36%, P(1)=64%",
          "difficulty": "easy"
        }
      ],
      "realWorldApplications": [
        {"title": "Quantum State Preparation", "description": "Initializing qubits in desired states"},
        {"title": "Quantum Tomography", "description": "Reconstructing wave functions experimentally"},
        {"title": "Quantum Chemistry", "description": "Molecular wave functions for simulations"}
      ],
      "codeExample": {
        "python": "import numpy as np\nfrom qiskit.quantum_info import Statevector\n\n# Create normalized state |œà‚ü© = (3|0‚ü© + 4|1‚ü©)/5\nalpha = 3/5\nbeta = 4/5\n\n# As a numpy array\npsi = np.array([alpha, beta])\n\n# Verify normalization\nnorm = np.sum(np.abs(psi)**2)\nprint(f'State: |œà‚ü© = {alpha}|0‚ü© + {beta}|1‚ü©')\nprint(f'Norm (should be 1): {norm:.4f}')\n\n# Probabilities\np0 = np.abs(alpha)**2\np1 = np.abs(beta)**2\nprint(f'P(|0‚ü©) = {p0:.2%}')\nprint(f'P(|1‚ü©) = {p1:.2%}')\n\n# Using Qiskit's Statevector\nsv = Statevector([alpha, beta])\nprint(f'\\nQiskit Statevector: {sv}')\nprint(f'Probabilities: {sv.probabilities()}')"
      },
      "tips": [
        "Always normalize your states before using them",
        "Complex amplitudes carry phase information critical for interference",
        "The global phase doesn't matter, but relative phases do"
      ]
    },
    {
      "id": "probability_amplitude",
      "title": "Probability Amplitudes",
      "symbol": "üìä",
      "level": "intermediate",
      "definition": {
        "text": "Probability amplitudes are complex numbers whose squared magnitudes give probabilities. Unlike classical probabilities, amplitudes can interfere constructively (adding) or destructively (canceling). This interference is the source of quantum computational power - algorithms like Grover's use it to amplify correct answers while canceling wrong ones. Phase matters!",
        "keyTerms": ["Complex Numbers", "Phase", "Interference", "Constructive", "Destructive", "Amplitude", "Born Rule"]
      },
      "keyFormulas": [
        {
          "id": "complex_amp",
          "name": "Complex Amplitude",
          "formula": "Œ± = |Œ±|e^(iœÜ) = r(cos œÜ + i sin œÜ)",
          "latex": "\\alpha = |\\alpha|e^{i\\phi} = r(\\cos\\phi + i\\sin\\phi)",
          "meaning": "r = magnitude, œÜ = phase"
        },
        {
          "id": "interference",
          "name": "Interference",
          "formula": "|Œ± + Œ≤|¬≤ = |Œ±|¬≤ + |Œ≤|¬≤ + 2Re(Œ±*Œ≤)",
          "latex": "|\\alpha + \\beta|^2 = |\\alpha|^2 + |\\beta|^2 + 2\\text{Re}(\\alpha^*\\beta)",
          "meaning": "Third term causes interference"
        }
      ],
      "examples": [
        {
          "id": "amp_ex1",
          "question": "Two paths have amplitudes Œ± = 1/‚àö2 and Œ≤ = e^(iœÄ)¬∑1/‚àö2 = -1/‚àö2. What's the probability when combined?",
          "steps": [
            {"step": 1, "action": "Add amplitudes", "result": "Œ± + Œ≤ = 1/‚àö2 - 1/‚àö2 = 0", "explanation": "Destructive interference"},
            {"step": 2, "action": "Calculate probability", "result": "|Œ± + Œ≤|¬≤ = 0", "explanation": "Complete cancellation!"},
            {"step": 3, "action": "Compare to classical", "result": "|Œ±|¬≤ + |Œ≤|¬≤ = 1/2 + 1/2 = 1", "explanation": "Classical would give 100%"}
          ],
          "finalAnswer": "P = 0 (destructive interference - quantum gives 0%, classical would give 100%!)",
          "difficulty": "medium"
        }
      ],
      "realWorldApplications": [
        {"title": "Grover's Algorithm", "description": "Amplitude amplification for search"},
        {"title": "Quantum Interference", "description": "All quantum speedups rely on this"},
        {"title": "Quantum Walks", "description": "Quantum analog of random walks"}
      ],
      "codeExample": {
        "python": "import numpy as np\n\n# Demonstrate interference\ndef interference_example():\n    # Two amplitudes with different phases\n    r = 1/np.sqrt(2)\n    \n    # Same phase (constructive)\n    alpha1 = r * np.exp(1j * 0)      # Phase 0\n    beta1 = r * np.exp(1j * 0)       # Phase 0\n    constructive = np.abs(alpha1 + beta1)**2\n    \n    # Opposite phase (destructive)\n    alpha2 = r * np.exp(1j * 0)      # Phase 0\n    beta2 = r * np.exp(1j * np.pi)   # Phase œÄ\n    destructive = np.abs(alpha2 + beta2)**2\n    \n    # Classical (no interference)\n    classical = np.abs(alpha1)**2 + np.abs(beta1)**2\n    \n    print('Quantum Interference Demo')\n    print('=' * 40)\n    print(f'Two paths, each with amplitude 1/‚àö2')\n    print(f'\\nSame phase (constructive):')\n    print(f'  P = |1/‚àö2 + 1/‚àö2|¬≤ = {constructive:.0f} (100%)')\n    print(f'\\nOpposite phase (destructive):')\n    print(f'  P = |1/‚àö2 - 1/‚àö2|¬≤ = {destructive:.0f} (0%)')\n    print(f'\\nClassical (no interference):')\n    print(f'  P = 1/2 + 1/2 = {classical:.0f} (100%)')\n\ninterference_example()"
      },
      "tips": [
        "Phase is invisible in single measurements but crucial for algorithms",
        "Quantum algorithms work by making wrong answers interfere destructively",
        "The minus sign in Œ≤ = -1/‚àö2 vs Œ≤ = 1/‚àö2 changes everything!"
      ]
    }
  ]
}

